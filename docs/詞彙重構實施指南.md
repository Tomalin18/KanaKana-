# è©å½™è³‡æ–™åº«é‡æ§‹å¯¦æ–½æŒ‡å—

## ğŸš€ å¿«é€Ÿé–‹å§‹

### ç¬¬ä¸€æ­¥ï¼šç’°å¢ƒæº–å‚™

```bash
# 1. å‰µå»ºæ–°çš„ç›®éŒ„çµæ§‹
mkdir -p src/data/vocabulary/{core,data,services,adapters}
mkdir -p src/data/vocabulary/data/jlpt

# 2. å®‰è£å¿…è¦ä¾è³´
npm install --save-dev typescript @types/node
```

### ç¬¬äºŒæ­¥ï¼šå‰µå»ºæ ¸å¿ƒæª”æ¡ˆ

#### 1. çµ±ä¸€é¡å‹å®šç¾©
```typescript
// src/data/vocabulary/core/types.ts
export interface VocabularyWord {
  id: string;
  word: string;
  kana: string;
  meaning: string;
  chineseMeaning?: string;
  difficulty: 'beginner' | 'normal' | 'hard' | 'expert';
  category: string;
  tags: string[];
  jlptLevel?: 'n1' | 'n2' | 'n3' | 'n4' | 'n5';
  kanji?: string;
  isKanji: boolean;
  gameModes: string[];
  wordLength: number;
  createdAt: string;
  updatedAt: string;
  source: string;
}

export interface VocabularyQueryOptions {
  difficulty?: string;
  jlptLevel?: string;
  gameModes?: string[];
  tags?: string[];
  category?: string;
  wordLength?: number;
  limit?: number;
}
```

#### 2. ä¸»å…¥å£æª”æ¡ˆ
```typescript
// src/data/vocabulary/core/index.ts
export * from './types';
export { VocabularyService } from '../services/VocabularyService';
export { GameModeAdapter } from '../adapters/GameModeAdapter';
```

### ç¬¬ä¸‰æ­¥ï¼šå¯¦ç¾æ ¸å¿ƒæœå‹™

#### 1. è©å½™æœå‹™é¡
```typescript
// src/data/vocabulary/services/VocabularyService.ts
import { VocabularyWord, VocabularyQueryOptions } from '../core/types';

export class VocabularyService {
  private static instance: VocabularyService;
  private vocabulary: VocabularyWord[] = [];
  private cache: Map<string, VocabularyWord[]> = new Map();
  
  static getInstance(): VocabularyService {
    if (!VocabularyService.instance) {
      VocabularyService.instance = new VocabularyService();
    }
    return VocabularyService.instance;
  }
  
  async initialize(): Promise<void> {
    console.log('ğŸ”„ åˆå§‹åŒ–è©å½™æœå‹™...');
    // è¼‰å…¥æ‰€æœ‰è©å½™è³‡æ–™
    this.vocabulary = await this.loadAllWords();
    console.log(`âœ… è©å½™æœå‹™åˆå§‹åŒ–å®Œæˆï¼Œå…±è¼‰å…¥ ${this.vocabulary.length} å€‹å–®å­—`);
  }
  
  query(options: VocabularyQueryOptions): VocabularyWord[] {
    const cacheKey = JSON.stringify(options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    let result = this.vocabulary.filter(word => this.matchesQuery(word, options));
    
    if (options.limit) {
      result = result.slice(0, options.limit);
    }
    
    this.cache.set(cacheKey, result);
    return result;
  }
  
  getRandom(options: VocabularyQueryOptions): VocabularyWord {
    const words = this.query(options);
    if (words.length === 0) {
      throw new Error('æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„è©å½™');
    }
    return words[Math.floor(Math.random() * words.length)];
  }
  
  private matchesQuery(word: VocabularyWord, options: VocabularyQueryOptions): boolean {
    if (options.difficulty && word.difficulty !== options.difficulty) return false;
    if (options.jlptLevel && word.jlptLevel !== options.jlptLevel) return false;
    if (options.category && word.category !== options.category) return false;
    if (options.wordLength && word.wordLength !== options.wordLength) return false;
    
    if (options.gameModes && !options.gameModes.some(mode => word.gameModes.includes(mode))) {
      return false;
    }
    
    if (options.tags && !options.tags.some(tag => word.tags.includes(tag))) {
      return false;
    }
    
    return true;
  }
  
  private async loadAllWords(): Promise<VocabularyWord[]> {
    // é€™è£¡æœƒè¼‰å…¥æ‰€æœ‰è©å½™è³‡æ–™
    // æš«æ™‚è¿”å›ç©ºé™£åˆ—ï¼Œå¾ŒçºŒæœƒå¯¦ç¾
    return [];
  }
}
```

#### 2. éŠæˆ²æ¨¡å¼é©é…å™¨
```typescript
// src/data/vocabulary/adapters/GameModeAdapter.ts
import { VocabularyService } from '../services/VocabularyService';
import { VocabularyWord } from '../core/types';

export class GameModeAdapter {
  private static service = VocabularyService.getInstance();
  
  // ç¶“å…¸æ¨¡å¼
  static forClassicMode(difficulty: string): VocabularyWord[] {
    const difficultyMap = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    
    const mappedDifficulty = difficultyMap[difficulty] || 'normal';
    
    return this.service.query({
      difficulty: mappedDifficulty,
      gameModes: ['classic']
    });
  }
  
  // ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼
  static forTetrisMode(difficulty: string, wordType: string): VocabularyWord[] {
    return this.service.query({
      difficulty,
      gameModes: ['tetris'],
      tags: [wordType]
    });
  }
  
  // æ¼¢å­—æ¨¡å¼
  static forKanjiMode(jlptLevel: string): VocabularyWord[] {
    return this.service.query({
      jlptLevel,
      gameModes: ['kanji'],
      tags: ['kanji']
    });
  }
  
  // å‘å¾Œç›¸å®¹çš„éš¨æ©Ÿè©å½™å‡½æ•¸
  static getRandomWord(difficulty: string, gameMode: string): VocabularyWord {
    switch (gameMode) {
      case 'classic':
        const words = this.forClassicMode(difficulty);
        return words[Math.floor(Math.random() * words.length)];
      
      case 'tetris':
        return this.service.getRandom({
          difficulty: this.mapDifficulty(difficulty),
          gameModes: ['tetris']
        });
      
      case 'kanji':
        return this.service.getRandom({
          gameModes: ['kanji'],
          tags: ['kanji']
        });
      
      default:
        return this.service.getRandom({
          gameModes: [gameMode]
        });
    }
  }
  
  private static mapDifficulty(combined: string): string {
    const map = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    return map[combined] || 'normal';
  }
}
```

### ç¬¬å››æ­¥ï¼šè³‡æ–™è½‰æ›è…³æœ¬

```typescript
// scripts/migrate-vocabulary.ts
import * as fs from 'fs';
import * as path from 'path';
import { VocabularyWord } from '../src/data/vocabulary/core/types';

export class VocabularyMigrator {
  private static readonly INPUT_DIR = '../src/data/vocabulary-final';
  private static readonly OUTPUT_DIR = '../src/data/vocabulary/data';
  
  static async migrateAllFiles(): Promise<void> {
    console.log('ğŸ”„ é–‹å§‹è©å½™è³‡æ–™é·ç§»...');
    
    const files = [
      'beginner_converted.ts',
      'normal 2.ts',
      'hard 2.ts',
      'expert 2.ts'
    ];
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      console.log(`ğŸ“ è™•ç†æª”æ¡ˆ: ${file}`);
      const words = await this.migrateFile(file);
      allWords = allWords.concat(words);
    }
    
    // è™•ç†JLPTè©å½™
    console.log('ğŸ“š è™•ç†JLPTè©å½™...');
    const jlptWords = await this.migrateJLPTWords();
    allWords = allWords.concat(jlptWords);
    
    // å»é‡è™•ç†
    console.log('ğŸ” åŸ·è¡Œå»é‡è™•ç†...');
    allWords = this.deduplicate(allWords);
    
    // æ¨™ç±¤åŒ–è™•ç†
    console.log('ğŸ·ï¸ åŸ·è¡Œæ¨™ç±¤åŒ–è™•ç†...');
    allWords = this.addTags(allWords);
    
    // ä¿å­˜çµæœ
    console.log('ğŸ’¾ ä¿å­˜è½‰æ›çµæœ...');
    await this.saveResults(allWords);
    
    console.log(`âœ… é·ç§»å®Œæˆï¼å…±è™•ç† ${allWords.length} å€‹è©å½™`);
  }
  
  private static async migrateFile(filename: string): Promise<VocabularyWord[]> {
    const filePath = path.join(__dirname, this.INPUT_DIR, filename);
    const content = fs.readFileSync(filePath, 'utf8');
    
    // è§£æTypeScriptæª”æ¡ˆä¸­çš„è©å½™é™£åˆ—
    const words = this.parseTypeScriptArray(content);
    
    // è½‰æ›ç‚ºçµ±ä¸€æ ¼å¼
    return words.map(word => this.convertToVocabularyWord(word, filename));
  }
  
  private static convertToVocabularyWord(word: any, source: string): VocabularyWord {
    return {
      id: word.id || this.generateId(),
      word: word.word,
      kana: word.kana,
      meaning: word.meaning,
      chineseMeaning: word.chineseMeaning || word.meaning,
      difficulty: word.difficulty,
      category: word.category || 'ä¸€èˆ¬',
      tags: this.generateTags(word),
      jlptLevel: word.jlptLevel,
      kanji: word.kanji,
      isKanji: word.isKanji || false,
      gameModes: this.determineGameModes(word),
      wordLength: word.word.length,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      source: source
    };
  }
  
  private static generateTags(word: any): string[] {
    const tags: string[] = [];
    
    if (word.jlptLevel) {
      tags.push(`jlpt_${word.jlptLevel}`);
    }
    
    if (word.isKanji) {
      tags.push('kanji');
    } else {
      tags.push('kana');
    }
    
    if (word.word.length <= 2) {
      tags.push('short');
    } else if (word.word.length <= 4) {
      tags.push('medium');
    } else {
      tags.push('long');
    }
    
    return tags;
  }
  
  private static determineGameModes(word: any): string[] {
    const modes: string[] = ['classic'];
    
    if (word.isKanji) {
      modes.push('kanji');
    }
    
    if (word.word.length <= 4) {
      modes.push('tetris');
    }
    
    return modes;
  }
  
  private static deduplicate(words: VocabularyWord[]): VocabularyWord[] {
    const seen = new Set<string>();
    const unique: VocabularyWord[] = [];
    
    for (const word of words) {
      const key = `${word.word}-${word.kana}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(word);
      }
    }
    
    return unique;
  }
  
  private static async saveResults(words: VocabularyWord[]): Promise<void> {
    const outputPath = path.join(__dirname, this.OUTPUT_DIR, 'all-words.json');
    
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(words, null, 2), 'utf8');
  }
  
  private static generateId(): string {
    return `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private static parseTypeScriptArray(content: string): any[] {
    // ç°¡å–®çš„è§£æé‚è¼¯ï¼Œå¯¦éš›ä½¿ç”¨æ™‚éœ€è¦æ›´è¤‡é›œçš„è§£æ
    const match = content.match(/export const \w+_WORDS = (\[[\s\S]*?\]);/);
    if (match) {
      try {
        return eval(match[1]);
      } catch (e) {
        console.error('è§£æå¤±æ•—:', e);
        return [];
      }
    }
    return [];
  }
}

// åŸ·è¡Œé·ç§»
if (require.main === module) {
  VocabularyMigrator.migrateAllFiles().catch(console.error);
}
```

### ç¬¬äº”æ­¥ï¼šæ›´æ–°éŠæˆ²æ¨¡å¼

#### 1. æ›´æ–°ç¶“å…¸æ¨¡å¼
```typescript
// src/screens/main/GameScreen.tsx
import { GameModeAdapter } from '../../data/vocabulary/adapters/GameModeAdapter';

// æ›¿æ›ç¾æœ‰çš„è©å½™ç²å–é‚è¼¯
const getRandomWord = (difficulty: CombinedDifficultyLevel): TetrisWord => {
  return GameModeAdapter.getRandomWord(difficulty, 'classic');
};
```

#### 2. æ›´æ–°ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼
```typescript
// src/screens/game-modes/TetrisModeScreen.tsx
import { GameModeAdapter } from '../../data/vocabulary/adapters/GameModeAdapter';

// æ›¿æ›ç¾æœ‰çš„è©å½™ç²å–é‚è¼¯
const getRandomWord = (difficulty: DifficultyLevel, wordType: string): TetrisWord => {
  return GameModeAdapter.getRandomWord(difficulty, 'tetris');
};
```

### ç¬¬å…­æ­¥ï¼šæ¸¬è©¦å’Œé©—è­‰

#### 1. å‰µå»ºæ¸¬è©¦è…³æœ¬
```typescript
// scripts/test-vocabulary.ts
import { VocabularyService } from '../src/data/vocabulary/services/VocabularyService';
import { GameModeAdapter } from '../src/data/vocabulary/adapters/GameModeAdapter';

async function testVocabularyService() {
  console.log('ğŸ§ª æ¸¬è©¦è©å½™æœå‹™...');
  
  const service = VocabularyService.getInstance();
  await service.initialize();
  
  // æ¸¬è©¦æŸ¥è©¢åŠŸèƒ½
  const classicWords = service.query({ gameModes: ['classic'] });
  console.log(`ç¶“å…¸æ¨¡å¼è©å½™æ•¸é‡: ${classicWords.length}`);
  
  const tetrisWords = service.query({ gameModes: ['tetris'] });
  console.log(`ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼è©å½™æ•¸é‡: ${tetrisWords.length}`);
  
  const kanjiWords = service.query({ gameModes: ['kanji'] });
  console.log(`æ¼¢å­—æ¨¡å¼è©å½™æ•¸é‡: ${kanjiWords.length}`);
  
  // æ¸¬è©¦éš¨æ©Ÿç²å–
  const randomWord = service.getRandom({ difficulty: 'normal' });
  console.log('éš¨æ©Ÿè©å½™:', randomWord);
  
  console.log('âœ… æ¸¬è©¦å®Œæˆ');
}

testVocabularyService().catch(console.error);
```

#### 2. é‹è¡Œæ¸¬è©¦
```bash
# ç·¨è­¯ä¸¦é‹è¡Œæ¸¬è©¦
npx tsc scripts/test-vocabulary.ts --outDir dist
node dist/scripts/test-vocabulary.js
```

## ğŸ“‹ æª¢æŸ¥æ¸…å–®

### æº–å‚™éšæ®µ
- [ ] å‰µå»ºæ–°çš„ç›®éŒ„çµæ§‹
- [ ] å®‰è£å¿…è¦ä¾è³´
- [ ] å‰µå»ºæ ¸å¿ƒé¡å‹å®šç¾©
- [ ] å‰µå»ºä¸»å…¥å£æª”æ¡ˆ

### å¯¦ç¾éšæ®µ
- [ ] å¯¦ç¾ VocabularyService
- [ ] å¯¦ç¾ GameModeAdapter
- [ ] å‰µå»ºè³‡æ–™è½‰æ›è…³æœ¬
- [ ] åŸ·è¡Œè³‡æ–™è½‰æ›

### æ•´åˆéšæ®µ
- [ ] æ›´æ–°ç¶“å…¸æ¨¡å¼
- [ ] æ›´æ–°ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼
- [ ] æ›´æ–°æ¼¢å­—æ¨¡å¼
- [ ] æ›´æ–°é•·æ–‡æ¨¡å¼

### æ¸¬è©¦éšæ®µ
- [ ] å‰µå»ºæ¸¬è©¦è…³æœ¬
- [ ] é‹è¡Œå–®å…ƒæ¸¬è©¦
- [ ] é‹è¡Œæ•´åˆæ¸¬è©¦
- [ ] é©—è­‰å‘å¾Œç›¸å®¹æ€§

## ğŸš¨ æ³¨æ„äº‹é …

1. **å‚™ä»½ç¾æœ‰è³‡æ–™**: åœ¨é–‹å§‹é‡æ§‹å‰ï¼Œå‹™å¿…å‚™ä»½ç¾æœ‰çš„è©å½™æª”æ¡ˆ
2. **é€æ­¥é·ç§»**: å»ºè­°å…ˆå¯¦ç¾æ–°æ¶æ§‹ï¼Œå†é€æ­¥é·ç§»ç¾æœ‰åŠŸèƒ½
3. **å‘å¾Œç›¸å®¹**: ç¢ºä¿ç¾æœ‰éŠæˆ²æ¨¡å¼åœ¨é·ç§»éç¨‹ä¸­ä»èƒ½æ­£å¸¸é‹è¡Œ
4. **æ¸¬è©¦å……åˆ†**: æ¯å€‹éšæ®µéƒ½è¦é€²è¡Œå……åˆ†æ¸¬è©¦

## ğŸ“ æ”¯æ´

å¦‚æœåœ¨å¯¦æ–½éç¨‹ä¸­é‡åˆ°å•é¡Œï¼Œè«‹ï¼š
1. æª¢æŸ¥éŒ¯èª¤æ—¥èªŒ
2. ç¢ºèªæª”æ¡ˆè·¯å¾‘æ­£ç¢º
3. é©—è­‰TypeScriptç·¨è­¯ç„¡éŒ¯èª¤
4. åƒè€ƒå®Œæ•´æŠ€è¡“æ–‡ä»¶

---

**é€™å€‹æŒ‡å—æä¾›äº†é‡æ§‹çš„åŸºæœ¬æ­¥é©Ÿï¼Œå·¥ç¨‹å¸«å¯ä»¥æ ¹æ“šå¯¦éš›æƒ…æ³èª¿æ•´å¯¦æ–½é †åºå’Œç´°ç¯€ã€‚** 