# 詞彙資料庫重構實施指南

## 🚀 快速開始

### 第一步：環境準備

```bash
# 1. 創建新的目錄結構
mkdir -p src/data/vocabulary/{core,data,services,adapters}
mkdir -p src/data/vocabulary/data/jlpt

# 2. 安裝必要依賴
npm install --save-dev typescript @types/node
```

### 第二步：創建核心檔案

#### 1. 統一類型定義
```typescript
// src/data/vocabulary/core/types.ts
export interface VocabularyWord {
  id: string;
  word: string;
  kana: string;
  meaning: string;
  chineseMeaning?: string;
  difficulty: 'beginner' | 'normal' | 'hard' | 'expert';
  category: string;
  tags: string[];
  jlptLevel?: 'n1' | 'n2' | 'n3' | 'n4' | 'n5';
  kanji?: string;
  isKanji: boolean;
  gameModes: string[];
  wordLength: number;
  createdAt: string;
  updatedAt: string;
  source: string;
}

export interface VocabularyQueryOptions {
  difficulty?: string;
  jlptLevel?: string;
  gameModes?: string[];
  tags?: string[];
  category?: string;
  wordLength?: number;
  limit?: number;
}
```

#### 2. 主入口檔案
```typescript
// src/data/vocabulary/core/index.ts
export * from './types';
export { VocabularyService } from '../services/VocabularyService';
export { GameModeAdapter } from '../adapters/GameModeAdapter';
```

### 第三步：實現核心服務

#### 1. 詞彙服務類
```typescript
// src/data/vocabulary/services/VocabularyService.ts
import { VocabularyWord, VocabularyQueryOptions } from '../core/types';

export class VocabularyService {
  private static instance: VocabularyService;
  private vocabulary: VocabularyWord[] = [];
  private cache: Map<string, VocabularyWord[]> = new Map();
  
  static getInstance(): VocabularyService {
    if (!VocabularyService.instance) {
      VocabularyService.instance = new VocabularyService();
    }
    return VocabularyService.instance;
  }
  
  async initialize(): Promise<void> {
    console.log('🔄 初始化詞彙服務...');
    // 載入所有詞彙資料
    this.vocabulary = await this.loadAllWords();
    console.log(`✅ 詞彙服務初始化完成，共載入 ${this.vocabulary.length} 個單字`);
  }
  
  query(options: VocabularyQueryOptions): VocabularyWord[] {
    const cacheKey = JSON.stringify(options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    let result = this.vocabulary.filter(word => this.matchesQuery(word, options));
    
    if (options.limit) {
      result = result.slice(0, options.limit);
    }
    
    this.cache.set(cacheKey, result);
    return result;
  }
  
  getRandom(options: VocabularyQueryOptions): VocabularyWord {
    const words = this.query(options);
    if (words.length === 0) {
      throw new Error('沒有符合條件的詞彙');
    }
    return words[Math.floor(Math.random() * words.length)];
  }
  
  private matchesQuery(word: VocabularyWord, options: VocabularyQueryOptions): boolean {
    if (options.difficulty && word.difficulty !== options.difficulty) return false;
    if (options.jlptLevel && word.jlptLevel !== options.jlptLevel) return false;
    if (options.category && word.category !== options.category) return false;
    if (options.wordLength && word.wordLength !== options.wordLength) return false;
    
    if (options.gameModes && !options.gameModes.some(mode => word.gameModes.includes(mode))) {
      return false;
    }
    
    if (options.tags && !options.tags.some(tag => word.tags.includes(tag))) {
      return false;
    }
    
    return true;
  }
  
  private async loadAllWords(): Promise<VocabularyWord[]> {
    // 這裡會載入所有詞彙資料
    // 暫時返回空陣列，後續會實現
    return [];
  }
}
```

#### 2. 遊戲模式適配器
```typescript
// src/data/vocabulary/adapters/GameModeAdapter.ts
import { VocabularyService } from '../services/VocabularyService';
import { VocabularyWord } from '../core/types';

export class GameModeAdapter {
  private static service = VocabularyService.getInstance();
  
  // 經典模式
  static forClassicMode(difficulty: string): VocabularyWord[] {
    const difficultyMap = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    
    const mappedDifficulty = difficultyMap[difficulty] || 'normal';
    
    return this.service.query({
      difficulty: mappedDifficulty,
      gameModes: ['classic']
    });
  }
  
  // 俄羅斯方塊模式
  static forTetrisMode(difficulty: string, wordType: string): VocabularyWord[] {
    return this.service.query({
      difficulty,
      gameModes: ['tetris'],
      tags: [wordType]
    });
  }
  
  // 漢字模式
  static forKanjiMode(jlptLevel: string): VocabularyWord[] {
    return this.service.query({
      jlptLevel,
      gameModes: ['kanji'],
      tags: ['kanji']
    });
  }
  
  // 向後相容的隨機詞彙函數
  static getRandomWord(difficulty: string, gameMode: string): VocabularyWord {
    switch (gameMode) {
      case 'classic':
        const words = this.forClassicMode(difficulty);
        return words[Math.floor(Math.random() * words.length)];
      
      case 'tetris':
        return this.service.getRandom({
          difficulty: this.mapDifficulty(difficulty),
          gameModes: ['tetris']
        });
      
      case 'kanji':
        return this.service.getRandom({
          gameModes: ['kanji'],
          tags: ['kanji']
        });
      
      default:
        return this.service.getRandom({
          gameModes: [gameMode]
        });
    }
  }
  
  private static mapDifficulty(combined: string): string {
    const map = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    return map[combined] || 'normal';
  }
}
```

### 第四步：資料轉換腳本

```typescript
// scripts/migrate-vocabulary.ts
import * as fs from 'fs';
import * as path from 'path';
import { VocabularyWord } from '../src/data/vocabulary/core/types';

export class VocabularyMigrator {
  private static readonly INPUT_DIR = '../src/data/vocabulary-final';
  private static readonly OUTPUT_DIR = '../src/data/vocabulary/data';
  
  static async migrateAllFiles(): Promise<void> {
    console.log('🔄 開始詞彙資料遷移...');
    
    const files = [
      'beginner_converted.ts',
      'normal 2.ts',
      'hard 2.ts',
      'expert 2.ts'
    ];
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      console.log(`📁 處理檔案: ${file}`);
      const words = await this.migrateFile(file);
      allWords = allWords.concat(words);
    }
    
    // 處理JLPT詞彙
    console.log('📚 處理JLPT詞彙...');
    const jlptWords = await this.migrateJLPTWords();
    allWords = allWords.concat(jlptWords);
    
    // 去重處理
    console.log('🔍 執行去重處理...');
    allWords = this.deduplicate(allWords);
    
    // 標籤化處理
    console.log('🏷️ 執行標籤化處理...');
    allWords = this.addTags(allWords);
    
    // 保存結果
    console.log('💾 保存轉換結果...');
    await this.saveResults(allWords);
    
    console.log(`✅ 遷移完成！共處理 ${allWords.length} 個詞彙`);
  }
  
  private static async migrateFile(filename: string): Promise<VocabularyWord[]> {
    const filePath = path.join(__dirname, this.INPUT_DIR, filename);
    const content = fs.readFileSync(filePath, 'utf8');
    
    // 解析TypeScript檔案中的詞彙陣列
    const words = this.parseTypeScriptArray(content);
    
    // 轉換為統一格式
    return words.map(word => this.convertToVocabularyWord(word, filename));
  }
  
  private static convertToVocabularyWord(word: any, source: string): VocabularyWord {
    return {
      id: word.id || this.generateId(),
      word: word.word,
      kana: word.kana,
      meaning: word.meaning,
      chineseMeaning: word.chineseMeaning || word.meaning,
      difficulty: word.difficulty,
      category: word.category || '一般',
      tags: this.generateTags(word),
      jlptLevel: word.jlptLevel,
      kanji: word.kanji,
      isKanji: word.isKanji || false,
      gameModes: this.determineGameModes(word),
      wordLength: word.word.length,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      source: source
    };
  }
  
  private static generateTags(word: any): string[] {
    const tags: string[] = [];
    
    if (word.jlptLevel) {
      tags.push(`jlpt_${word.jlptLevel}`);
    }
    
    if (word.isKanji) {
      tags.push('kanji');
    } else {
      tags.push('kana');
    }
    
    if (word.word.length <= 2) {
      tags.push('short');
    } else if (word.word.length <= 4) {
      tags.push('medium');
    } else {
      tags.push('long');
    }
    
    return tags;
  }
  
  private static determineGameModes(word: any): string[] {
    const modes: string[] = ['classic'];
    
    if (word.isKanji) {
      modes.push('kanji');
    }
    
    if (word.word.length <= 4) {
      modes.push('tetris');
    }
    
    return modes;
  }
  
  private static deduplicate(words: VocabularyWord[]): VocabularyWord[] {
    const seen = new Set<string>();
    const unique: VocabularyWord[] = [];
    
    for (const word of words) {
      const key = `${word.word}-${word.kana}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(word);
      }
    }
    
    return unique;
  }
  
  private static async saveResults(words: VocabularyWord[]): Promise<void> {
    const outputPath = path.join(__dirname, this.OUTPUT_DIR, 'all-words.json');
    
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(words, null, 2), 'utf8');
  }
  
  private static generateId(): string {
    return `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private static parseTypeScriptArray(content: string): any[] {
    // 簡單的解析邏輯，實際使用時需要更複雜的解析
    const match = content.match(/export const \w+_WORDS = (\[[\s\S]*?\]);/);
    if (match) {
      try {
        return eval(match[1]);
      } catch (e) {
        console.error('解析失敗:', e);
        return [];
      }
    }
    return [];
  }
}

// 執行遷移
if (require.main === module) {
  VocabularyMigrator.migrateAllFiles().catch(console.error);
}
```

### 第五步：更新遊戲模式

#### 1. 更新經典模式
```typescript
// src/screens/main/GameScreen.tsx
import { GameModeAdapter } from '../../data/vocabulary/adapters/GameModeAdapter';

// 替換現有的詞彙獲取邏輯
const getRandomWord = (difficulty: CombinedDifficultyLevel): TetrisWord => {
  return GameModeAdapter.getRandomWord(difficulty, 'classic');
};
```

#### 2. 更新俄羅斯方塊模式
```typescript
// src/screens/game-modes/TetrisModeScreen.tsx
import { GameModeAdapter } from '../../data/vocabulary/adapters/GameModeAdapter';

// 替換現有的詞彙獲取邏輯
const getRandomWord = (difficulty: DifficultyLevel, wordType: string): TetrisWord => {
  return GameModeAdapter.getRandomWord(difficulty, 'tetris');
};
```

### 第六步：測試和驗證

#### 1. 創建測試腳本
```typescript
// scripts/test-vocabulary.ts
import { VocabularyService } from '../src/data/vocabulary/services/VocabularyService';
import { GameModeAdapter } from '../src/data/vocabulary/adapters/GameModeAdapter';

async function testVocabularyService() {
  console.log('🧪 測試詞彙服務...');
  
  const service = VocabularyService.getInstance();
  await service.initialize();
  
  // 測試查詢功能
  const classicWords = service.query({ gameModes: ['classic'] });
  console.log(`經典模式詞彙數量: ${classicWords.length}`);
  
  const tetrisWords = service.query({ gameModes: ['tetris'] });
  console.log(`俄羅斯方塊模式詞彙數量: ${tetrisWords.length}`);
  
  const kanjiWords = service.query({ gameModes: ['kanji'] });
  console.log(`漢字模式詞彙數量: ${kanjiWords.length}`);
  
  // 測試隨機獲取
  const randomWord = service.getRandom({ difficulty: 'normal' });
  console.log('隨機詞彙:', randomWord);
  
  console.log('✅ 測試完成');
}

testVocabularyService().catch(console.error);
```

#### 2. 運行測試
```bash
# 編譯並運行測試
npx tsc scripts/test-vocabulary.ts --outDir dist
node dist/scripts/test-vocabulary.js
```

## 📋 檢查清單

### 準備階段
- [ ] 創建新的目錄結構
- [ ] 安裝必要依賴
- [ ] 創建核心類型定義
- [ ] 創建主入口檔案

### 實現階段
- [ ] 實現 VocabularyService
- [ ] 實現 GameModeAdapter
- [ ] 創建資料轉換腳本
- [ ] 執行資料轉換

### 整合階段
- [ ] 更新經典模式
- [ ] 更新俄羅斯方塊模式
- [ ] 更新漢字模式
- [ ] 更新長文模式

### 測試階段
- [ ] 創建測試腳本
- [ ] 運行單元測試
- [ ] 運行整合測試
- [ ] 驗證向後相容性

## 🚨 注意事項

1. **備份現有資料**: 在開始重構前，務必備份現有的詞彙檔案
2. **逐步遷移**: 建議先實現新架構，再逐步遷移現有功能
3. **向後相容**: 確保現有遊戲模式在遷移過程中仍能正常運行
4. **測試充分**: 每個階段都要進行充分測試

## 📞 支援

如果在實施過程中遇到問題，請：
1. 檢查錯誤日誌
2. 確認檔案路徑正確
3. 驗證TypeScript編譯無錯誤
4. 參考完整技術文件

---

**這個指南提供了重構的基本步驟，工程師可以根據實際情況調整實施順序和細節。** 