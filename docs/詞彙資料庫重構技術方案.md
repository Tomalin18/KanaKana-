# 詞彙資料庫重構技術方案

## 📋 文件概述

**文件目的**: 為工程師提供詞彙資料庫重構的詳細技術方案，包括當前問題分析、重構設計邏輯、實施計劃和技術細節。

**適用對象**: 專案工程師、技術負責人
**文件版本**: v1.0
**創建日期**: 2025-08-02

---

## 🎯 專案背景

### 1.1 當前狀況

KanaKana是一款日語學習遊戲，目前包含4個遊戲模式：
- **經典模式** (Classic Mode): 基礎打字練習
- **俄羅斯方塊模式** (Tetris Mode): 結合方塊遊戲的打字練習
- **漢字模式** (Kanji Mode): 漢字識別練習
- **長文模式** (Long Text Mode): 長篇文章打字練習

### 1.2 詞彙資料庫現狀

目前詞彙資料庫包含 **11,357個單字**，分布在以下檔案中：

```
src/data/vocabulary-final/
├── index.ts                    # 主索引檔案 (經典模式使用)
├── index 2.ts                  # 第二索引檔案 (俄羅斯方塊模式使用)
├── beginner_converted.ts       # 初級詞彙 (860個)
├── normal 2.ts                 # 中級詞彙 (2,538個)
├── hard 2.ts                   # 高級詞彙 (1,545個)
├── expert 2.ts                 # 專家級詞彙 (2,633個)
├── jlpt-chunks/                # JLPT詞彙 (3,781個)
│   ├── index.ts
│   ├── chunk-1.ts
│   ├── chunk-2.ts
│   └── ... (共8個分塊檔案)
├── kanji-01.ts ~ kanji-07.ts   # 漢字詞彙檔案
├── hiragana.ts                 # 平假名詞彙
└── 其他重複檔案...
```

---

## ⚠️ 當前問題分析

### 2.1 技術問題

#### 2.1.1 檔案分散和重複
- **重複檔案**: 存在多個版本的相同檔案 (如 `kanji-01.ts` 和 `kanji-01 2.ts`)
- **多個索引**: `index.ts` 和 `index 2.ts` 功能重複但略有不同
- **介面重複**: 多個檔案重複定義 `TetrisWord` 介面

#### 2.1.2 管理困難
- **更新複雜**: 新增詞彙需要修改多個檔案
- **版本控制**: 難以追蹤詞彙的變更歷史
- **測試困難**: 分散的檔案難以進行統一測試

#### 2.1.3 擴展性問題
- **新模式困難**: 新增遊戲模式需要重新整合詞彙
- **查詢效率**: 分散的檔案影響查詢效率
- **維護成本**: 需要維護多套相似的邏輯

### 2.2 業務問題

#### 2.2.1 開發效率低
- 工程師需要了解多個檔案的結構才能修改詞彙
- 新增詞彙分類需要修改多個地方
- 除錯時需要檢查多個檔案

#### 2.2.2 資料一致性風險
- 不同檔案中的詞彙可能不一致
- 難度等級分配可能不統一
- JLPT等級標記可能遺漏

---

## 🏗️ 重構設計方案

### 3.1 設計原則

1. **單一資料來源**: 所有詞彙統一管理
2. **服務導向**: 提供統一的詞彙服務API
3. **可擴展性**: 支援未來新增遊戲模式和詞彙分類
4. **向後相容**: 確保現有遊戲模式不受影響
5. **性能優化**: 支援快取和高效查詢

### 3.2 新架構設計

#### 3.2.1 目錄結構

```
src/data/vocabulary/
├── core/                       # 核心組件
│   ├── index.ts               # 主入口檔案
│   ├── types.ts               # 統一類型定義
│   ├── metadata.ts            # 元資料管理
│   └── utils.ts               # 工具函數
├── data/                      # 詞彙資料
│   ├── all-words.json         # 所有詞彙 (JSON格式)
│   ├── beginner.json          # 初級詞彙
│   ├── intermediate.json      # 中級詞彙
│   ├── advanced.json          # 高級詞彙
│   ├── expert.json            # 專家級詞彙
│   └── jlpt/                  # JLPT詞彙
│       ├── n5.json
│       ├── n4.json
│       ├── n3.json
│       ├── n2.json
│       └── n1.json
├── services/                  # 服務層
│   ├── VocabularyService.ts   # 詞彙服務類
│   ├── QueryService.ts        # 查詢服務
│   └── CacheService.ts        # 快取服務
└── adapters/                  # 適配器層
    ├── GameModeAdapter.ts     # 遊戲模式適配器
    ├── DifficultyAdapter.ts   # 難度適配器
    └── ExportAdapter.ts       # 匯出適配器
```

#### 3.2.2 統一資料結構

```typescript
// src/data/vocabulary/core/types.ts
export interface VocabularyWord {
  // 基本資訊
  id: string;                    // 唯一識別碼
  word: string;                  // 日文單字
  kana: string;                  // 假名讀音
  meaning: string;               // 英文意思
  chineseMeaning?: string;       // 中文意思
  
  // 分類標籤
  difficulty: DifficultyLevel;   // 難度等級
  category: string;              // 分類 (一般、食物、交通等)
  tags: string[];                // 標籤陣列 (JLPT、漢字、假名等)
  
  // JLPT相關
  jlptLevel?: 'n1' | 'n2' | 'n3' | 'n4' | 'n5';
  
  // 漢字相關
  kanji?: string;                // 漢字版本
  isKanji: boolean;              // 是否為漢字
  strokeCount?: number;          // 筆畫數
  
  // 遊戲相關
  gameModes: GameMode[];         // 適用遊戲模式
  wordLength: number;            // 單字長度
  frequency: number;             // 使用頻率
  
  // 元資料
  createdAt: string;             // 創建時間
  updatedAt: string;             // 更新時間
  source: string;                // 資料來源
}

export interface VocabularyMetadata {
  totalWords: number;
  difficultyDistribution: Record<DifficultyLevel, number>;
  jlptDistribution: Record<string, number>;
  categoryDistribution: Record<string, number>;
  lastUpdated: string;
  version: string;
}

export interface VocabularyQueryOptions {
  difficulty?: DifficultyLevel;
  jlptLevel?: string;
  gameModes?: GameMode[];
  tags?: string[];
  category?: string;
  wordLength?: number;
  limit?: number;
}
```

### 3.3 核心服務設計

#### 3.3.1 詞彙服務類

```typescript
// src/data/vocabulary/services/VocabularyService.ts
export class VocabularyService {
  private static instance: VocabularyService;
  private vocabulary: VocabularyWord[] = [];
  private metadata: VocabularyMetadata;
  private cache: Map<string, VocabularyWord[]> = new Map();
  
  // 單例模式確保全局唯一實例
  static getInstance(): VocabularyService {
    if (!VocabularyService.instance) {
      VocabularyService.instance = new VocabularyService();
    }
    return VocabularyService.instance;
  }
  
  // 初始化詞彙庫
  async initialize(): Promise<void> {
    console.log('🔄 初始化詞彙服務...');
    this.vocabulary = await this.loadAllWords();
    this.metadata = await this.loadMetadata();
    console.log(`✅ 詞彙服務初始化完成，共載入 ${this.vocabulary.length} 個單字`);
  }
  
  // 根據條件查詢詞彙
  query(options: VocabularyQueryOptions): VocabularyWord[] {
    const cacheKey = this.generateCacheKey(options);
    
    // 檢查快取
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    // 執行查詢
    let result = this.vocabulary.filter(word => this.matchesQuery(word, options));
    
    // 限制結果數量
    if (options.limit) {
      result = result.slice(0, options.limit);
    }
    
    // 儲存到快取
    this.cache.set(cacheKey, result);
    
    return result;
  }
  
  // 獲取隨機詞彙
  getRandom(options: VocabularyQueryOptions): VocabularyWord {
    const words = this.query(options);
    if (words.length === 0) {
      throw new Error('沒有符合條件的詞彙');
    }
    return words[Math.floor(Math.random() * words.length)];
  }
  
  // 獲取統計資訊
  getStatistics(): VocabularyMetadata {
    return this.metadata;
  }
  
  // 新增詞彙
  async addWord(word: VocabularyWord): Promise<void> {
    // 驗證詞彙資料
    this.validateWord(word);
    
    // 生成唯一ID
    word.id = this.generateId();
    word.createdAt = new Date().toISOString();
    word.updatedAt = new Date().toISOString();
    
    this.vocabulary.push(word);
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // 更新詞彙
  async updateWord(id: string, updates: Partial<VocabularyWord>): Promise<void> {
    const index = this.vocabulary.findIndex(w => w.id === id);
    if (index === -1) {
      throw new Error(`詞彙不存在: ${id}`);
    }
    
    this.vocabulary[index] = { 
      ...this.vocabulary[index], 
      ...updates,
      updatedAt: new Date().toISOString()
    };
    
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // 刪除詞彙
  async deleteWord(id: string): Promise<void> {
    const initialLength = this.vocabulary.length;
    this.vocabulary = this.vocabulary.filter(w => w.id !== id);
    
    if (this.vocabulary.length === initialLength) {
      throw new Error(`詞彙不存在: ${id}`);
    }
    
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // 私有方法
  private matchesQuery(word: VocabularyWord, options: VocabularyQueryOptions): boolean {
    if (options.difficulty && word.difficulty !== options.difficulty) return false;
    if (options.jlptLevel && word.jlptLevel !== options.jlptLevel) return false;
    if (options.category && word.category !== options.category) return false;
    if (options.wordLength && word.wordLength !== options.wordLength) return false;
    
    if (options.gameModes && !options.gameModes.some(mode => word.gameModes.includes(mode))) {
      return false;
    }
    
    if (options.tags && !options.tags.some(tag => word.tags.includes(tag))) {
      return false;
    }
    
    return true;
  }
  
  private generateCacheKey(options: VocabularyQueryOptions): string {
    return JSON.stringify(options);
  }
  
  private clearCache(): void {
    this.cache.clear();
  }
  
  private validateWord(word: VocabularyWord): void {
    if (!word.word || !word.kana || !word.meaning) {
      throw new Error('詞彙必須包含 word、kana 和 meaning');
    }
    
    if (!word.difficulty || !word.category) {
      throw new Error('詞彙必須包含 difficulty 和 category');
    }
    
    if (!word.gameModes || word.gameModes.length === 0) {
      throw new Error('詞彙必須包含至少一個遊戲模式');
    }
  }
  
  private generateId(): string {
    return `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

#### 3.3.2 查詢服務

```typescript
// src/data/vocabulary/services/QueryService.ts
export class QueryService {
  // 根據難度查詢
  static byDifficulty(words: VocabularyWord[], difficulty: DifficultyLevel): VocabularyWord[] {
    return words.filter(word => word.difficulty === difficulty);
  }
  
  // 根據JLPT等級查詢
  static byJLPTLevel(words: VocabularyWord[], level: string): VocabularyWord[] {
    return words.filter(word => word.jlptLevel === level);
  }
  
  // 根據遊戲模式查詢
  static byGameMode(words: VocabularyWord[], mode: GameMode): VocabularyWord[] {
    return words.filter(word => word.gameModes.includes(mode));
  }
  
  // 根據單字長度查詢
  static byLength(words: VocabularyWord[], length: number): VocabularyWord[] {
    return words.filter(word => word.wordLength === length);
  }
  
  // 根據標籤查詢
  static byTags(words: VocabularyWord[], tags: string[]): VocabularyWord[] {
    return words.filter(word => tags.some(tag => word.tags.includes(tag)));
  }
  
  // 複合查詢
  static complexQuery(words: VocabularyWord[], options: ComplexQueryOptions): VocabularyWord[] {
    let result = words;
    
    if (options.difficulty) {
      result = this.byDifficulty(result, options.difficulty);
    }
    
    if (options.jlptLevel) {
      result = this.byJLPTLevel(result, options.jlptLevel);
    }
    
    if (options.gameMode) {
      result = this.byGameMode(result, options.gameMode);
    }
    
    if (options.length) {
      result = this.byLength(result, options.length);
    }
    
    if (options.tags) {
      result = this.byTags(result, options.tags);
    }
    
    return result;
  }
  
  // 統計查詢
  static getStatistics(words: VocabularyWord[]): VocabularyStatistics {
    const difficultyStats = {};
    const jlptStats = {};
    const categoryStats = {};
    const gameModeStats = {};
    
    words.forEach(word => {
      // 難度統計
      difficultyStats[word.difficulty] = (difficultyStats[word.difficulty] || 0) + 1;
      
      // JLPT統計
      if (word.jlptLevel) {
        jlptStats[word.jlptLevel] = (jlptStats[word.jlptLevel] || 0) + 1;
      }
      
      // 分類統計
      categoryStats[word.category] = (categoryStats[word.category] || 0) + 1;
      
      // 遊戲模式統計
      word.gameModes.forEach(mode => {
        gameModeStats[mode] = (gameModeStats[mode] || 0) + 1;
      });
    });
    
    return {
      totalWords: words.length,
      difficultyDistribution: difficultyStats,
      jlptDistribution: jlptStats,
      categoryDistribution: categoryStats,
      gameModeDistribution: gameModeStats
    };
  }
}
```

### 3.4 適配器設計

#### 3.4.1 遊戲模式適配器

```typescript
// src/data/vocabulary/adapters/GameModeAdapter.ts
export class GameModeAdapter {
  private static service = VocabularyService.getInstance();
  
  // 經典模式適配器
  static forClassicMode(difficulty: CombinedDifficultyLevel): VocabularyWord[] {
    const difficultyMap = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    
    const mappedDifficulty = difficultyMap[difficulty] || 'normal';
    
    return this.service.query({
      difficulty: mappedDifficulty,
      gameModes: ['classic']
    });
  }
  
  // 俄羅斯方塊模式適配器
  static forTetrisMode(difficulty: DifficultyLevel, wordType: string): VocabularyWord[] {
    return this.service.query({
      difficulty,
      gameModes: ['tetris'],
      tags: [wordType]
    });
  }
  
  // 漢字模式適配器
  static forKanjiMode(jlptLevel: string): VocabularyWord[] {
    return this.service.query({
      jlptLevel,
      gameModes: ['kanji'],
      tags: ['kanji']
    });
  }
  
  // 長文模式適配器
  static forLongTextMode(category: string): VocabularyWord[] {
    return this.service.query({
      category,
      gameModes: ['long_text'],
      tags: ['long_text']
    });
  }
  
  // 獲取隨機詞彙 (向後相容)
  static getRandomWord(difficulty: CombinedDifficultyLevel, gameMode: GameMode): VocabularyWord {
    switch (gameMode) {
      case 'classic':
        const words = this.forClassicMode(difficulty);
        return words[Math.floor(Math.random() * words.length)];
      
      case 'tetris':
        return this.service.getRandom({
          difficulty: this.mapDifficulty(difficulty),
          gameModes: ['tetris']
        });
      
      case 'kanji':
        return this.service.getRandom({
          gameModes: ['kanji'],
          tags: ['kanji']
        });
      
      default:
        return this.service.getRandom({
          gameModes: [gameMode]
        });
    }
  }
  
  private static mapDifficulty(combined: CombinedDifficultyLevel): DifficultyLevel {
    const map = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    return map[combined] || 'normal';
  }
}
```

---

## 📅 實施計劃

### 4.1 階段規劃

#### 階段1: 準備階段 (1-2天)
**目標**: 建立新架構基礎
**任務**:
- [ ] 創建新的目錄結構
- [ ] 定義統一介面
- [ ] 建立資料轉換腳本
- [ ] 設置開發環境

**交付物**:
- 新的目錄結構
- 統一介面定義
- 資料轉換腳本

#### 階段2: 資料整合 (2-3天)
**目標**: 將現有詞彙轉換為統一格式
**任務**:
- [ ] 分析現有詞彙檔案結構
- [ ] 編寫資料轉換腳本
- [ ] 執行資料轉換
- [ ] 去重處理
- [ ] 標籤化處理
- [ ] 資料驗證

**交付物**:
- 轉換後的統一詞彙資料
- 資料驗證報告
- 統計資訊

#### 階段3: 服務實現 (2-3天)
**目標**: 實現核心服務功能
**任務**:
- [ ] 實現 VocabularyService
- [ ] 實現 QueryService
- [ ] 實現快取機制
- [ ] 實現適配器
- [ ] 單元測試

**交付物**:
- 核心服務類
- 適配器類
- 單元測試

#### 階段4: 遊戲模式更新 (2-3天)
**目標**: 更新所有遊戲模式使用新服務
**任務**:
- [ ] 更新經典模式
- [ ] 更新俄羅斯方塊模式
- [ ] 更新漢字模式
- [ ] 更新長文模式
- [ ] 向後相容性測試

**交付物**:
- 更新的遊戲模式
- 相容性測試報告

#### 階段5: 測試和優化 (1-2天)
**目標**: 確保系統穩定性和性能
**任務**:
- [ ] 整合測試
- [ ] 性能測試
- [ ] 用戶體驗測試
- [ ] 文件更新
- [ ] 部署準備

**交付物**:
- 測試報告
- 性能報告
- 更新文件

### 4.2 風險管理

#### 4.2.1 技術風險
- **風險**: 資料轉換過程中可能丟失資料
- **緩解**: 建立完整的備份和回滾機制
- **監控**: 資料完整性檢查

#### 4.2.2 時間風險
- **風險**: 重構時間可能超出預期
- **緩解**: 分階段實施，每階段都有可交付物
- **監控**: 定期進度檢查

#### 4.2.3 相容性風險
- **風險**: 新架構可能與現有代碼不相容
- **緩解**: 保持向後相容性，逐步遷移
- **監控**: 持續測試

---

## 🛠️ 技術實現細節

### 5.1 資料轉換腳本

```typescript
// scripts/migrate-vocabulary.ts
export class VocabularyMigrator {
  private static readonly INPUT_DIR = '../src/data/vocabulary-final';
  private static readonly OUTPUT_DIR = '../src/data/vocabulary/data';
  
  // 轉換所有檔案
  static async migrateAllFiles(): Promise<void> {
    console.log('🔄 開始詞彙資料遷移...');
    
    const files = [
      'beginner_converted.ts',
      'normal 2.ts',
      'hard 2.ts',
      'expert 2.ts'
    ];
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      console.log(`📁 處理檔案: ${file}`);
      const words = await this.migrateFile(file);
      allWords = allWords.concat(words);
    }
    
    // 處理JLPT詞彙
    console.log('📚 處理JLPT詞彙...');
    const jlptWords = await this.migrateJLPTWords();
    allWords = allWords.concat(jlptWords);
    
    // 去重處理
    console.log('🔍 執行去重處理...');
    allWords = this.deduplicate(allWords);
    
    // 標籤化處理
    console.log('🏷️ 執行標籤化處理...');
    allWords = this.addTags(allWords);
    
    // 保存結果
    console.log('💾 保存轉換結果...');
    await this.saveResults(allWords);
    
    console.log(`✅ 遷移完成！共處理 ${allWords.length} 個詞彙`);
  }
  
  // 轉換單個檔案
  private static async migrateFile(filename: string): Promise<VocabularyWord[]> {
    const filePath = path.join(__dirname, this.INPUT_DIR, filename);
    const content = fs.readFileSync(filePath, 'utf8');
    
    // 解析TypeScript檔案中的詞彙陣列
    const words = this.parseTypeScriptArray(content);
    
    // 轉換為統一格式
    return words.map(word => this.convertToVocabularyWord(word, filename));
  }
  
  // 轉換JLPT詞彙
  private static async migrateJLPTWords(): Promise<VocabularyWord[]> {
    const jlptDir = path.join(__dirname, this.INPUT_DIR, 'jlpt-chunks');
    const files = fs.readdirSync(jlptDir).filter(file => file.startsWith('chunk-'));
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      const filePath = path.join(jlptDir, file);
      const content = fs.readFileSync(filePath, 'utf8');
      const words = this.parseTypeScriptArray(content);
      
      const convertedWords = words.map(word => 
        this.convertToVocabularyWord(word, `jlpt-chunks/${file}`)
      );
      
      allWords = allWords.concat(convertedWords);
    }
    
    return allWords;
  }
  
  // 轉換為統一格式
  private static convertToVocabularyWord(word: any, source: string): VocabularyWord {
    return {
      id: word.id || this.generateId(),
      word: word.word,
      kana: word.kana,
      meaning: word.meaning,
      chineseMeaning: word.chineseMeaning || word.meaning,
      difficulty: word.difficulty,
      category: word.category || '一般',
      tags: this.generateTags(word),
      jlptLevel: word.jlptLevel,
      kanji: word.kanji,
      isKanji: word.isKanji || false,
      strokeCount: word.strokeCount,
      gameModes: this.determineGameModes(word),
      wordLength: word.word.length,
      frequency: word.frequency || 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      source: source
    };
  }
  
  // 生成標籤
  private static generateTags(word: any): string[] {
    const tags: string[] = [];
    
    // JLPT標籤
    if (word.jlptLevel) {
      tags.push(`jlpt_${word.jlptLevel}`);
    }
    
    // 漢字標籤
    if (word.isKanji) {
      tags.push('kanji');
    }
    
    // 假名標籤
    if (!word.isKanji) {
      tags.push('kana');
    }
    
    // 長度標籤
    if (word.word.length <= 2) {
      tags.push('short');
    } else if (word.word.length <= 4) {
      tags.push('medium');
    } else {
      tags.push('long');
    }
    
    return tags;
  }
  
  // 確定遊戲模式
  private static determineGameModes(word: any): GameMode[] {
    const modes: GameMode[] = ['classic'];
    
    // 根據詞彙特徵決定適用模式
    if (word.isKanji) {
      modes.push('kanji');
    }
    
    if (word.word.length <= 4) {
      modes.push('tetris');
    }
    
    return modes;
  }
  
  // 去重處理
  private static deduplicate(words: VocabularyWord[]): VocabularyWord[] {
    const seen = new Set<string>();
    const unique: VocabularyWord[] = [];
    
    for (const word of words) {
      const key = `${word.word}-${word.kana}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(word);
      }
    }
    
    return unique;
  }
  
  // 保存結果
  private static async saveResults(words: VocabularyWord[]): Promise<void> {
    const outputPath = path.join(__dirname, this.OUTPUT_DIR, 'all-words.json');
    
    // 確保目錄存在
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    
    // 保存所有詞彙
    fs.writeFileSync(outputPath, JSON.stringify(words, null, 2), 'utf8');
    
    // 按難度分類保存
    const difficultyGroups = this.groupByDifficulty(words);
    for (const [difficulty, groupWords] of Object.entries(difficultyGroups)) {
      const groupPath = path.join(__dirname, this.OUTPUT_DIR, `${difficulty}.json`);
      fs.writeFileSync(groupPath, JSON.stringify(groupWords, null, 2), 'utf8');
    }
    
    // 按JLPT等級分類保存
    const jlptGroups = this.groupByJLPT(words);
    const jlptDir = path.join(__dirname, this.OUTPUT_DIR, 'jlpt');
    fs.mkdirSync(jlptDir, { recursive: true });
    
    for (const [level, levelWords] of Object.entries(jlptGroups)) {
      const levelPath = path.join(jlptDir, `${level}.json`);
      fs.writeFileSync(levelPath, JSON.stringify(levelWords, null, 2), 'utf8');
    }
  }
}
```

### 5.2 驗證腳本

```typescript
// scripts/validate-vocabulary.ts
export class VocabularyValidator {
  // 驗證資料完整性
  static async validateIntegrity(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    await service.initialize();
    
    const words = service.getAllWords();
    const errors: string[] = [];
    
    // 檢查必填欄位
    words.forEach((word, index) => {
      if (!word.word || !word.kana || !word.meaning) {
        errors.push(`詞彙 ${index}: 缺少必填欄位`);
      }
      
      if (!word.difficulty || !word.category) {
        errors.push(`詞彙 ${index}: 缺少分類資訊`);
      }
      
      if (!word.gameModes || word.gameModes.length === 0) {
        errors.push(`詞彙 ${index}: 缺少遊戲模式`);
      }
    });
    
    // 檢查重複
    const duplicates = this.findDuplicates(words);
    if (duplicates.length > 0) {
      errors.push(`發現重複詞彙: ${duplicates.join(', ')}`);
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      totalWords: words.length
    };
  }
  
  // 驗證統計資訊
  static async validateStatistics(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    const stats = service.getStatistics();
    
    const errors: string[] = [];
    
    // 檢查總數是否合理
    if (stats.totalWords < 10000) {
      errors.push('詞彙總數過少，可能資料丟失');
    }
    
    // 檢查難度分布
    const difficultySum = Object.values(stats.difficultyDistribution).reduce((a, b) => a + b, 0);
    if (difficultySum !== stats.totalWords) {
      errors.push('難度分布統計不正確');
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      statistics: stats
    };
  }
  
  // 驗證遊戲模式相容性
  static async validateGameModeCompatibility(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    const gameModes: GameMode[] = ['classic', 'tetris', 'kanji', 'long_text'];
    
    const errors: string[] = [];
    
    for (const mode of gameModes) {
      const words = service.query({ gameModes: [mode] });
      
      if (words.length === 0) {
        errors.push(`遊戲模式 ${mode} 沒有可用詞彙`);
      }
      
      if (words.length < 100) {
        errors.push(`遊戲模式 ${mode} 詞彙數量過少: ${words.length}`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      gameModeStats: gameModes.map(mode => ({
        mode,
        wordCount: service.query({ gameModes: [mode] }).length
      }))
    };
  }
}
```

---

## 📈 預期效益

### 6.1 技術效益

#### 6.1.1 開發效率提升
- **統一API**: 所有遊戲模式使用相同的詞彙API
- **快速查詢**: 高效的詞彙查詢機制
- **易於擴展**: 新增遊戲模式或詞彙分類更容易
- **程式碼重用**: 減少重複程式碼

#### 6.1.2 維護成本降低
- **單一資料來源**: 避免資料不一致
- **自動化測試**: 更容易進行測試
- **版本控制**: 清晰的變更歷史
- **文件完整**: 清晰的API文件

#### 6.1.3 性能優化
- **快取機制**: 提高查詢效率
- **記憶體優化**: 減少重複載入
- **查詢優化**: 高效的過濾和排序

### 6.2 業務效益

#### 6.2.1 管理效率提升
- **統一管理**: 所有詞彙在一個地方管理
- **自動化**: 減少手動操作錯誤
- **可追蹤**: 清晰的變更歷史

#### 6.2.2 用戶體驗提升
- **更豐富的詞彙**: 更好的詞彙分類和標籤
- **更智能的推薦**: 基於用戶行為的詞彙推薦
- **更流暢的遊戲**: 更快的詞彙載入速度

#### 6.2.3 擴展性提升
- **新模式支援**: 更容易新增遊戲模式
- **詞彙擴展**: 更容易新增詞彙分類
- **功能擴展**: 更容易新增功能

---

## 🎯 結論

### 7.1 重構必要性

基於當前詞彙資料庫的問題分析，重構是必要的：

1. **技術債務**: 當前架構存在大量技術債務
2. **維護困難**: 分散的檔案結構導致維護困難
3. **擴展限制**: 現有架構限制了功能擴展
4. **效率問題**: 重複的邏輯和檔案影響開發效率

### 7.2 重構價值

重構將帶來以下價值：

1. **技術價值**: 建立現代化的詞彙管理系統
2. **業務價值**: 提高開發效率和用戶體驗
3. **長期價值**: 為未來擴展奠定基礎

### 7.3 實施建議

1. **分階段實施**: 按照計劃分階段進行，降低風險
2. **充分測試**: 每個階段都要進行充分測試
3. **向後相容**: 確保現有功能不受影響
4. **持續優化**: 根據使用情況持續優化

### 7.4 下一步行動

1. **技術評審**: 工程師團隊評審技術方案
2. **資源規劃**: 確定實施時間和人員安排
3. **開始實施**: 按照計劃開始重構工作
4. **定期檢查**: 定期檢查進度和質量

---

**文件結束**

這份技術文件提供了完整的重構方案，包括問題分析、設計邏輯、實施計劃和技術細節。工程師可以根據這份文件評估方案的可行性，並開始實施重構工作。 