# è©å½™è³‡æ–™åº«é‡æ§‹æŠ€è¡“æ–¹æ¡ˆ

## ğŸ“‹ æ–‡ä»¶æ¦‚è¿°

**æ–‡ä»¶ç›®çš„**: ç‚ºå·¥ç¨‹å¸«æä¾›è©å½™è³‡æ–™åº«é‡æ§‹çš„è©³ç´°æŠ€è¡“æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ç•¶å‰å•é¡Œåˆ†æã€é‡æ§‹è¨­è¨ˆé‚è¼¯ã€å¯¦æ–½è¨ˆåŠƒå’ŒæŠ€è¡“ç´°ç¯€ã€‚

**é©ç”¨å°è±¡**: å°ˆæ¡ˆå·¥ç¨‹å¸«ã€æŠ€è¡“è² è²¬äºº
**æ–‡ä»¶ç‰ˆæœ¬**: v1.0
**å‰µå»ºæ—¥æœŸ**: 2025-08-02

---

## ğŸ¯ å°ˆæ¡ˆèƒŒæ™¯

### 1.1 ç•¶å‰ç‹€æ³

KanaKanaæ˜¯ä¸€æ¬¾æ—¥èªå­¸ç¿’éŠæˆ²ï¼Œç›®å‰åŒ…å«4å€‹éŠæˆ²æ¨¡å¼ï¼š
- **ç¶“å…¸æ¨¡å¼** (Classic Mode): åŸºç¤æ‰“å­—ç·´ç¿’
- **ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼** (Tetris Mode): çµåˆæ–¹å¡ŠéŠæˆ²çš„æ‰“å­—ç·´ç¿’
- **æ¼¢å­—æ¨¡å¼** (Kanji Mode): æ¼¢å­—è­˜åˆ¥ç·´ç¿’
- **é•·æ–‡æ¨¡å¼** (Long Text Mode): é•·ç¯‡æ–‡ç« æ‰“å­—ç·´ç¿’

### 1.2 è©å½™è³‡æ–™åº«ç¾ç‹€

ç›®å‰è©å½™è³‡æ–™åº«åŒ…å« **11,357å€‹å–®å­—**ï¼Œåˆ†å¸ƒåœ¨ä»¥ä¸‹æª”æ¡ˆä¸­ï¼š

```
src/data/vocabulary-final/
â”œâ”€â”€ index.ts                    # ä¸»ç´¢å¼•æª”æ¡ˆ (ç¶“å…¸æ¨¡å¼ä½¿ç”¨)
â”œâ”€â”€ index 2.ts                  # ç¬¬äºŒç´¢å¼•æª”æ¡ˆ (ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼ä½¿ç”¨)
â”œâ”€â”€ beginner_converted.ts       # åˆç´šè©å½™ (860å€‹)
â”œâ”€â”€ normal 2.ts                 # ä¸­ç´šè©å½™ (2,538å€‹)
â”œâ”€â”€ hard 2.ts                   # é«˜ç´šè©å½™ (1,545å€‹)
â”œâ”€â”€ expert 2.ts                 # å°ˆå®¶ç´šè©å½™ (2,633å€‹)
â”œâ”€â”€ jlpt-chunks/                # JLPTè©å½™ (3,781å€‹)
â”‚   â”œâ”€â”€ index.ts
â”‚   â”œâ”€â”€ chunk-1.ts
â”‚   â”œâ”€â”€ chunk-2.ts
â”‚   â””â”€â”€ ... (å…±8å€‹åˆ†å¡Šæª”æ¡ˆ)
â”œâ”€â”€ kanji-01.ts ~ kanji-07.ts   # æ¼¢å­—è©å½™æª”æ¡ˆ
â”œâ”€â”€ hiragana.ts                 # å¹³å‡åè©å½™
â””â”€â”€ å…¶ä»–é‡è¤‡æª”æ¡ˆ...
```

---

## âš ï¸ ç•¶å‰å•é¡Œåˆ†æ

### 2.1 æŠ€è¡“å•é¡Œ

#### 2.1.1 æª”æ¡ˆåˆ†æ•£å’Œé‡è¤‡
- **é‡è¤‡æª”æ¡ˆ**: å­˜åœ¨å¤šå€‹ç‰ˆæœ¬çš„ç›¸åŒæª”æ¡ˆ (å¦‚ `kanji-01.ts` å’Œ `kanji-01 2.ts`)
- **å¤šå€‹ç´¢å¼•**: `index.ts` å’Œ `index 2.ts` åŠŸèƒ½é‡è¤‡ä½†ç•¥æœ‰ä¸åŒ
- **ä»‹é¢é‡è¤‡**: å¤šå€‹æª”æ¡ˆé‡è¤‡å®šç¾© `TetrisWord` ä»‹é¢

#### 2.1.2 ç®¡ç†å›°é›£
- **æ›´æ–°è¤‡é›œ**: æ–°å¢è©å½™éœ€è¦ä¿®æ”¹å¤šå€‹æª”æ¡ˆ
- **ç‰ˆæœ¬æ§åˆ¶**: é›£ä»¥è¿½è¹¤è©å½™çš„è®Šæ›´æ­·å²
- **æ¸¬è©¦å›°é›£**: åˆ†æ•£çš„æª”æ¡ˆé›£ä»¥é€²è¡Œçµ±ä¸€æ¸¬è©¦

#### 2.1.3 æ“´å±•æ€§å•é¡Œ
- **æ–°æ¨¡å¼å›°é›£**: æ–°å¢éŠæˆ²æ¨¡å¼éœ€è¦é‡æ–°æ•´åˆè©å½™
- **æŸ¥è©¢æ•ˆç‡**: åˆ†æ•£çš„æª”æ¡ˆå½±éŸ¿æŸ¥è©¢æ•ˆç‡
- **ç¶­è­·æˆæœ¬**: éœ€è¦ç¶­è­·å¤šå¥—ç›¸ä¼¼çš„é‚è¼¯

### 2.2 æ¥­å‹™å•é¡Œ

#### 2.2.1 é–‹ç™¼æ•ˆç‡ä½
- å·¥ç¨‹å¸«éœ€è¦äº†è§£å¤šå€‹æª”æ¡ˆçš„çµæ§‹æ‰èƒ½ä¿®æ”¹è©å½™
- æ–°å¢è©å½™åˆ†é¡éœ€è¦ä¿®æ”¹å¤šå€‹åœ°æ–¹
- é™¤éŒ¯æ™‚éœ€è¦æª¢æŸ¥å¤šå€‹æª”æ¡ˆ

#### 2.2.2 è³‡æ–™ä¸€è‡´æ€§é¢¨éšª
- ä¸åŒæª”æ¡ˆä¸­çš„è©å½™å¯èƒ½ä¸ä¸€è‡´
- é›£åº¦ç­‰ç´šåˆ†é…å¯èƒ½ä¸çµ±ä¸€
- JLPTç­‰ç´šæ¨™è¨˜å¯èƒ½éºæ¼

---

## ğŸ—ï¸ é‡æ§‹è¨­è¨ˆæ–¹æ¡ˆ

### 3.1 è¨­è¨ˆåŸå‰‡

1. **å–®ä¸€è³‡æ–™ä¾†æº**: æ‰€æœ‰è©å½™çµ±ä¸€ç®¡ç†
2. **æœå‹™å°å‘**: æä¾›çµ±ä¸€çš„è©å½™æœå‹™API
3. **å¯æ“´å±•æ€§**: æ”¯æ´æœªä¾†æ–°å¢éŠæˆ²æ¨¡å¼å’Œè©å½™åˆ†é¡
4. **å‘å¾Œç›¸å®¹**: ç¢ºä¿ç¾æœ‰éŠæˆ²æ¨¡å¼ä¸å—å½±éŸ¿
5. **æ€§èƒ½å„ªåŒ–**: æ”¯æ´å¿«å–å’Œé«˜æ•ˆæŸ¥è©¢

### 3.2 æ–°æ¶æ§‹è¨­è¨ˆ

#### 3.2.1 ç›®éŒ„çµæ§‹

```
src/data/vocabulary/
â”œâ”€â”€ core/                       # æ ¸å¿ƒçµ„ä»¶
â”‚   â”œâ”€â”€ index.ts               # ä¸»å…¥å£æª”æ¡ˆ
â”‚   â”œâ”€â”€ types.ts               # çµ±ä¸€é¡å‹å®šç¾©
â”‚   â”œâ”€â”€ metadata.ts            # å…ƒè³‡æ–™ç®¡ç†
â”‚   â””â”€â”€ utils.ts               # å·¥å…·å‡½æ•¸
â”œâ”€â”€ data/                      # è©å½™è³‡æ–™
â”‚   â”œâ”€â”€ all-words.json         # æ‰€æœ‰è©å½™ (JSONæ ¼å¼)
â”‚   â”œâ”€â”€ beginner.json          # åˆç´šè©å½™
â”‚   â”œâ”€â”€ intermediate.json      # ä¸­ç´šè©å½™
â”‚   â”œâ”€â”€ advanced.json          # é«˜ç´šè©å½™
â”‚   â”œâ”€â”€ expert.json            # å°ˆå®¶ç´šè©å½™
â”‚   â””â”€â”€ jlpt/                  # JLPTè©å½™
â”‚       â”œâ”€â”€ n5.json
â”‚       â”œâ”€â”€ n4.json
â”‚       â”œâ”€â”€ n3.json
â”‚       â”œâ”€â”€ n2.json
â”‚       â””â”€â”€ n1.json
â”œâ”€â”€ services/                  # æœå‹™å±¤
â”‚   â”œâ”€â”€ VocabularyService.ts   # è©å½™æœå‹™é¡
â”‚   â”œâ”€â”€ QueryService.ts        # æŸ¥è©¢æœå‹™
â”‚   â””â”€â”€ CacheService.ts        # å¿«å–æœå‹™
â””â”€â”€ adapters/                  # é©é…å™¨å±¤
    â”œâ”€â”€ GameModeAdapter.ts     # éŠæˆ²æ¨¡å¼é©é…å™¨
    â”œâ”€â”€ DifficultyAdapter.ts   # é›£åº¦é©é…å™¨
    â””â”€â”€ ExportAdapter.ts       # åŒ¯å‡ºé©é…å™¨
```

#### 3.2.2 çµ±ä¸€è³‡æ–™çµæ§‹

```typescript
// src/data/vocabulary/core/types.ts
export interface VocabularyWord {
  // åŸºæœ¬è³‡è¨Š
  id: string;                    // å”¯ä¸€è­˜åˆ¥ç¢¼
  word: string;                  // æ—¥æ–‡å–®å­—
  kana: string;                  // å‡åè®€éŸ³
  meaning: string;               // è‹±æ–‡æ„æ€
  chineseMeaning?: string;       // ä¸­æ–‡æ„æ€
  
  // åˆ†é¡æ¨™ç±¤
  difficulty: DifficultyLevel;   // é›£åº¦ç­‰ç´š
  category: string;              // åˆ†é¡ (ä¸€èˆ¬ã€é£Ÿç‰©ã€äº¤é€šç­‰)
  tags: string[];                // æ¨™ç±¤é™£åˆ— (JLPTã€æ¼¢å­—ã€å‡åç­‰)
  
  // JLPTç›¸é—œ
  jlptLevel?: 'n1' | 'n2' | 'n3' | 'n4' | 'n5';
  
  // æ¼¢å­—ç›¸é—œ
  kanji?: string;                // æ¼¢å­—ç‰ˆæœ¬
  isKanji: boolean;              // æ˜¯å¦ç‚ºæ¼¢å­—
  strokeCount?: number;          // ç­†ç•«æ•¸
  
  // éŠæˆ²ç›¸é—œ
  gameModes: GameMode[];         // é©ç”¨éŠæˆ²æ¨¡å¼
  wordLength: number;            // å–®å­—é•·åº¦
  frequency: number;             // ä½¿ç”¨é »ç‡
  
  // å…ƒè³‡æ–™
  createdAt: string;             // å‰µå»ºæ™‚é–“
  updatedAt: string;             // æ›´æ–°æ™‚é–“
  source: string;                // è³‡æ–™ä¾†æº
}

export interface VocabularyMetadata {
  totalWords: number;
  difficultyDistribution: Record<DifficultyLevel, number>;
  jlptDistribution: Record<string, number>;
  categoryDistribution: Record<string, number>;
  lastUpdated: string;
  version: string;
}

export interface VocabularyQueryOptions {
  difficulty?: DifficultyLevel;
  jlptLevel?: string;
  gameModes?: GameMode[];
  tags?: string[];
  category?: string;
  wordLength?: number;
  limit?: number;
}
```

### 3.3 æ ¸å¿ƒæœå‹™è¨­è¨ˆ

#### 3.3.1 è©å½™æœå‹™é¡

```typescript
// src/data/vocabulary/services/VocabularyService.ts
export class VocabularyService {
  private static instance: VocabularyService;
  private vocabulary: VocabularyWord[] = [];
  private metadata: VocabularyMetadata;
  private cache: Map<string, VocabularyWord[]> = new Map();
  
  // å–®ä¾‹æ¨¡å¼ç¢ºä¿å…¨å±€å”¯ä¸€å¯¦ä¾‹
  static getInstance(): VocabularyService {
    if (!VocabularyService.instance) {
      VocabularyService.instance = new VocabularyService();
    }
    return VocabularyService.instance;
  }
  
  // åˆå§‹åŒ–è©å½™åº«
  async initialize(): Promise<void> {
    console.log('ğŸ”„ åˆå§‹åŒ–è©å½™æœå‹™...');
    this.vocabulary = await this.loadAllWords();
    this.metadata = await this.loadMetadata();
    console.log(`âœ… è©å½™æœå‹™åˆå§‹åŒ–å®Œæˆï¼Œå…±è¼‰å…¥ ${this.vocabulary.length} å€‹å–®å­—`);
  }
  
  // æ ¹æ“šæ¢ä»¶æŸ¥è©¢è©å½™
  query(options: VocabularyQueryOptions): VocabularyWord[] {
    const cacheKey = this.generateCacheKey(options);
    
    // æª¢æŸ¥å¿«å–
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    // åŸ·è¡ŒæŸ¥è©¢
    let result = this.vocabulary.filter(word => this.matchesQuery(word, options));
    
    // é™åˆ¶çµæœæ•¸é‡
    if (options.limit) {
      result = result.slice(0, options.limit);
    }
    
    // å„²å­˜åˆ°å¿«å–
    this.cache.set(cacheKey, result);
    
    return result;
  }
  
  // ç²å–éš¨æ©Ÿè©å½™
  getRandom(options: VocabularyQueryOptions): VocabularyWord {
    const words = this.query(options);
    if (words.length === 0) {
      throw new Error('æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„è©å½™');
    }
    return words[Math.floor(Math.random() * words.length)];
  }
  
  // ç²å–çµ±è¨ˆè³‡è¨Š
  getStatistics(): VocabularyMetadata {
    return this.metadata;
  }
  
  // æ–°å¢è©å½™
  async addWord(word: VocabularyWord): Promise<void> {
    // é©—è­‰è©å½™è³‡æ–™
    this.validateWord(word);
    
    // ç”Ÿæˆå”¯ä¸€ID
    word.id = this.generateId();
    word.createdAt = new Date().toISOString();
    word.updatedAt = new Date().toISOString();
    
    this.vocabulary.push(word);
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // æ›´æ–°è©å½™
  async updateWord(id: string, updates: Partial<VocabularyWord>): Promise<void> {
    const index = this.vocabulary.findIndex(w => w.id === id);
    if (index === -1) {
      throw new Error(`è©å½™ä¸å­˜åœ¨: ${id}`);
    }
    
    this.vocabulary[index] = { 
      ...this.vocabulary[index], 
      ...updates,
      updatedAt: new Date().toISOString()
    };
    
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // åˆªé™¤è©å½™
  async deleteWord(id: string): Promise<void> {
    const initialLength = this.vocabulary.length;
    this.vocabulary = this.vocabulary.filter(w => w.id !== id);
    
    if (this.vocabulary.length === initialLength) {
      throw new Error(`è©å½™ä¸å­˜åœ¨: ${id}`);
    }
    
    await this.saveAllWords();
    await this.updateMetadata();
    this.clearCache();
  }
  
  // ç§æœ‰æ–¹æ³•
  private matchesQuery(word: VocabularyWord, options: VocabularyQueryOptions): boolean {
    if (options.difficulty && word.difficulty !== options.difficulty) return false;
    if (options.jlptLevel && word.jlptLevel !== options.jlptLevel) return false;
    if (options.category && word.category !== options.category) return false;
    if (options.wordLength && word.wordLength !== options.wordLength) return false;
    
    if (options.gameModes && !options.gameModes.some(mode => word.gameModes.includes(mode))) {
      return false;
    }
    
    if (options.tags && !options.tags.some(tag => word.tags.includes(tag))) {
      return false;
    }
    
    return true;
  }
  
  private generateCacheKey(options: VocabularyQueryOptions): string {
    return JSON.stringify(options);
  }
  
  private clearCache(): void {
    this.cache.clear();
  }
  
  private validateWord(word: VocabularyWord): void {
    if (!word.word || !word.kana || !word.meaning) {
      throw new Error('è©å½™å¿…é ˆåŒ…å« wordã€kana å’Œ meaning');
    }
    
    if (!word.difficulty || !word.category) {
      throw new Error('è©å½™å¿…é ˆåŒ…å« difficulty å’Œ category');
    }
    
    if (!word.gameModes || word.gameModes.length === 0) {
      throw new Error('è©å½™å¿…é ˆåŒ…å«è‡³å°‘ä¸€å€‹éŠæˆ²æ¨¡å¼');
    }
  }
  
  private generateId(): string {
    return `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

#### 3.3.2 æŸ¥è©¢æœå‹™

```typescript
// src/data/vocabulary/services/QueryService.ts
export class QueryService {
  // æ ¹æ“šé›£åº¦æŸ¥è©¢
  static byDifficulty(words: VocabularyWord[], difficulty: DifficultyLevel): VocabularyWord[] {
    return words.filter(word => word.difficulty === difficulty);
  }
  
  // æ ¹æ“šJLPTç­‰ç´šæŸ¥è©¢
  static byJLPTLevel(words: VocabularyWord[], level: string): VocabularyWord[] {
    return words.filter(word => word.jlptLevel === level);
  }
  
  // æ ¹æ“šéŠæˆ²æ¨¡å¼æŸ¥è©¢
  static byGameMode(words: VocabularyWord[], mode: GameMode): VocabularyWord[] {
    return words.filter(word => word.gameModes.includes(mode));
  }
  
  // æ ¹æ“šå–®å­—é•·åº¦æŸ¥è©¢
  static byLength(words: VocabularyWord[], length: number): VocabularyWord[] {
    return words.filter(word => word.wordLength === length);
  }
  
  // æ ¹æ“šæ¨™ç±¤æŸ¥è©¢
  static byTags(words: VocabularyWord[], tags: string[]): VocabularyWord[] {
    return words.filter(word => tags.some(tag => word.tags.includes(tag)));
  }
  
  // è¤‡åˆæŸ¥è©¢
  static complexQuery(words: VocabularyWord[], options: ComplexQueryOptions): VocabularyWord[] {
    let result = words;
    
    if (options.difficulty) {
      result = this.byDifficulty(result, options.difficulty);
    }
    
    if (options.jlptLevel) {
      result = this.byJLPTLevel(result, options.jlptLevel);
    }
    
    if (options.gameMode) {
      result = this.byGameMode(result, options.gameMode);
    }
    
    if (options.length) {
      result = this.byLength(result, options.length);
    }
    
    if (options.tags) {
      result = this.byTags(result, options.tags);
    }
    
    return result;
  }
  
  // çµ±è¨ˆæŸ¥è©¢
  static getStatistics(words: VocabularyWord[]): VocabularyStatistics {
    const difficultyStats = {};
    const jlptStats = {};
    const categoryStats = {};
    const gameModeStats = {};
    
    words.forEach(word => {
      // é›£åº¦çµ±è¨ˆ
      difficultyStats[word.difficulty] = (difficultyStats[word.difficulty] || 0) + 1;
      
      // JLPTçµ±è¨ˆ
      if (word.jlptLevel) {
        jlptStats[word.jlptLevel] = (jlptStats[word.jlptLevel] || 0) + 1;
      }
      
      // åˆ†é¡çµ±è¨ˆ
      categoryStats[word.category] = (categoryStats[word.category] || 0) + 1;
      
      // éŠæˆ²æ¨¡å¼çµ±è¨ˆ
      word.gameModes.forEach(mode => {
        gameModeStats[mode] = (gameModeStats[mode] || 0) + 1;
      });
    });
    
    return {
      totalWords: words.length,
      difficultyDistribution: difficultyStats,
      jlptDistribution: jlptStats,
      categoryDistribution: categoryStats,
      gameModeDistribution: gameModeStats
    };
  }
}
```

### 3.4 é©é…å™¨è¨­è¨ˆ

#### 3.4.1 éŠæˆ²æ¨¡å¼é©é…å™¨

```typescript
// src/data/vocabulary/adapters/GameModeAdapter.ts
export class GameModeAdapter {
  private static service = VocabularyService.getInstance();
  
  // ç¶“å…¸æ¨¡å¼é©é…å™¨
  static forClassicMode(difficulty: CombinedDifficultyLevel): VocabularyWord[] {
    const difficultyMap = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    
    const mappedDifficulty = difficultyMap[difficulty] || 'normal';
    
    return this.service.query({
      difficulty: mappedDifficulty,
      gameModes: ['classic']
    });
  }
  
  // ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼é©é…å™¨
  static forTetrisMode(difficulty: DifficultyLevel, wordType: string): VocabularyWord[] {
    return this.service.query({
      difficulty,
      gameModes: ['tetris'],
      tags: [wordType]
    });
  }
  
  // æ¼¢å­—æ¨¡å¼é©é…å™¨
  static forKanjiMode(jlptLevel: string): VocabularyWord[] {
    return this.service.query({
      jlptLevel,
      gameModes: ['kanji'],
      tags: ['kanji']
    });
  }
  
  // é•·æ–‡æ¨¡å¼é©é…å™¨
  static forLongTextMode(category: string): VocabularyWord[] {
    return this.service.query({
      category,
      gameModes: ['long_text'],
      tags: ['long_text']
    });
  }
  
  // ç²å–éš¨æ©Ÿè©å½™ (å‘å¾Œç›¸å®¹)
  static getRandomWord(difficulty: CombinedDifficultyLevel, gameMode: GameMode): VocabularyWord {
    switch (gameMode) {
      case 'classic':
        const words = this.forClassicMode(difficulty);
        return words[Math.floor(Math.random() * words.length)];
      
      case 'tetris':
        return this.service.getRandom({
          difficulty: this.mapDifficulty(difficulty),
          gameModes: ['tetris']
        });
      
      case 'kanji':
        return this.service.getRandom({
          gameModes: ['kanji'],
          tags: ['kanji']
        });
      
      default:
        return this.service.getRandom({
          gameModes: [gameMode]
        });
    }
  }
  
  private static mapDifficulty(combined: CombinedDifficultyLevel): DifficultyLevel {
    const map = {
      'elementary': 'beginner',
      'intermediate': 'normal',
      'advanced': 'hard'
    };
    return map[combined] || 'normal';
  }
}
```

---

## ğŸ“… å¯¦æ–½è¨ˆåŠƒ

### 4.1 éšæ®µè¦åŠƒ

#### éšæ®µ1: æº–å‚™éšæ®µ (1-2å¤©)
**ç›®æ¨™**: å»ºç«‹æ–°æ¶æ§‹åŸºç¤
**ä»»å‹™**:
- [ ] å‰µå»ºæ–°çš„ç›®éŒ„çµæ§‹
- [ ] å®šç¾©çµ±ä¸€ä»‹é¢
- [ ] å»ºç«‹è³‡æ–™è½‰æ›è…³æœ¬
- [ ] è¨­ç½®é–‹ç™¼ç’°å¢ƒ

**äº¤ä»˜ç‰©**:
- æ–°çš„ç›®éŒ„çµæ§‹
- çµ±ä¸€ä»‹é¢å®šç¾©
- è³‡æ–™è½‰æ›è…³æœ¬

#### éšæ®µ2: è³‡æ–™æ•´åˆ (2-3å¤©)
**ç›®æ¨™**: å°‡ç¾æœ‰è©å½™è½‰æ›ç‚ºçµ±ä¸€æ ¼å¼
**ä»»å‹™**:
- [ ] åˆ†æç¾æœ‰è©å½™æª”æ¡ˆçµæ§‹
- [ ] ç·¨å¯«è³‡æ–™è½‰æ›è…³æœ¬
- [ ] åŸ·è¡Œè³‡æ–™è½‰æ›
- [ ] å»é‡è™•ç†
- [ ] æ¨™ç±¤åŒ–è™•ç†
- [ ] è³‡æ–™é©—è­‰

**äº¤ä»˜ç‰©**:
- è½‰æ›å¾Œçš„çµ±ä¸€è©å½™è³‡æ–™
- è³‡æ–™é©—è­‰å ±å‘Š
- çµ±è¨ˆè³‡è¨Š

#### éšæ®µ3: æœå‹™å¯¦ç¾ (2-3å¤©)
**ç›®æ¨™**: å¯¦ç¾æ ¸å¿ƒæœå‹™åŠŸèƒ½
**ä»»å‹™**:
- [ ] å¯¦ç¾ VocabularyService
- [ ] å¯¦ç¾ QueryService
- [ ] å¯¦ç¾å¿«å–æ©Ÿåˆ¶
- [ ] å¯¦ç¾é©é…å™¨
- [ ] å–®å…ƒæ¸¬è©¦

**äº¤ä»˜ç‰©**:
- æ ¸å¿ƒæœå‹™é¡
- é©é…å™¨é¡
- å–®å…ƒæ¸¬è©¦

#### éšæ®µ4: éŠæˆ²æ¨¡å¼æ›´æ–° (2-3å¤©)
**ç›®æ¨™**: æ›´æ–°æ‰€æœ‰éŠæˆ²æ¨¡å¼ä½¿ç”¨æ–°æœå‹™
**ä»»å‹™**:
- [ ] æ›´æ–°ç¶“å…¸æ¨¡å¼
- [ ] æ›´æ–°ä¿„ç¾…æ–¯æ–¹å¡Šæ¨¡å¼
- [ ] æ›´æ–°æ¼¢å­—æ¨¡å¼
- [ ] æ›´æ–°é•·æ–‡æ¨¡å¼
- [ ] å‘å¾Œç›¸å®¹æ€§æ¸¬è©¦

**äº¤ä»˜ç‰©**:
- æ›´æ–°çš„éŠæˆ²æ¨¡å¼
- ç›¸å®¹æ€§æ¸¬è©¦å ±å‘Š

#### éšæ®µ5: æ¸¬è©¦å’Œå„ªåŒ– (1-2å¤©)
**ç›®æ¨™**: ç¢ºä¿ç³»çµ±ç©©å®šæ€§å’Œæ€§èƒ½
**ä»»å‹™**:
- [ ] æ•´åˆæ¸¬è©¦
- [ ] æ€§èƒ½æ¸¬è©¦
- [ ] ç”¨æˆ¶é«”é©—æ¸¬è©¦
- [ ] æ–‡ä»¶æ›´æ–°
- [ ] éƒ¨ç½²æº–å‚™

**äº¤ä»˜ç‰©**:
- æ¸¬è©¦å ±å‘Š
- æ€§èƒ½å ±å‘Š
- æ›´æ–°æ–‡ä»¶

### 4.2 é¢¨éšªç®¡ç†

#### 4.2.1 æŠ€è¡“é¢¨éšª
- **é¢¨éšª**: è³‡æ–™è½‰æ›éç¨‹ä¸­å¯èƒ½ä¸Ÿå¤±è³‡æ–™
- **ç·©è§£**: å»ºç«‹å®Œæ•´çš„å‚™ä»½å’Œå›æ»¾æ©Ÿåˆ¶
- **ç›£æ§**: è³‡æ–™å®Œæ•´æ€§æª¢æŸ¥

#### 4.2.2 æ™‚é–“é¢¨éšª
- **é¢¨éšª**: é‡æ§‹æ™‚é–“å¯èƒ½è¶…å‡ºé æœŸ
- **ç·©è§£**: åˆ†éšæ®µå¯¦æ–½ï¼Œæ¯éšæ®µéƒ½æœ‰å¯äº¤ä»˜ç‰©
- **ç›£æ§**: å®šæœŸé€²åº¦æª¢æŸ¥

#### 4.2.3 ç›¸å®¹æ€§é¢¨éšª
- **é¢¨éšª**: æ–°æ¶æ§‹å¯èƒ½èˆ‡ç¾æœ‰ä»£ç¢¼ä¸ç›¸å®¹
- **ç·©è§£**: ä¿æŒå‘å¾Œç›¸å®¹æ€§ï¼Œé€æ­¥é·ç§»
- **ç›£æ§**: æŒçºŒæ¸¬è©¦

---

## ğŸ› ï¸ æŠ€è¡“å¯¦ç¾ç´°ç¯€

### 5.1 è³‡æ–™è½‰æ›è…³æœ¬

```typescript
// scripts/migrate-vocabulary.ts
export class VocabularyMigrator {
  private static readonly INPUT_DIR = '../src/data/vocabulary-final';
  private static readonly OUTPUT_DIR = '../src/data/vocabulary/data';
  
  // è½‰æ›æ‰€æœ‰æª”æ¡ˆ
  static async migrateAllFiles(): Promise<void> {
    console.log('ğŸ”„ é–‹å§‹è©å½™è³‡æ–™é·ç§»...');
    
    const files = [
      'beginner_converted.ts',
      'normal 2.ts',
      'hard 2.ts',
      'expert 2.ts'
    ];
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      console.log(`ğŸ“ è™•ç†æª”æ¡ˆ: ${file}`);
      const words = await this.migrateFile(file);
      allWords = allWords.concat(words);
    }
    
    // è™•ç†JLPTè©å½™
    console.log('ğŸ“š è™•ç†JLPTè©å½™...');
    const jlptWords = await this.migrateJLPTWords();
    allWords = allWords.concat(jlptWords);
    
    // å»é‡è™•ç†
    console.log('ğŸ” åŸ·è¡Œå»é‡è™•ç†...');
    allWords = this.deduplicate(allWords);
    
    // æ¨™ç±¤åŒ–è™•ç†
    console.log('ğŸ·ï¸ åŸ·è¡Œæ¨™ç±¤åŒ–è™•ç†...');
    allWords = this.addTags(allWords);
    
    // ä¿å­˜çµæœ
    console.log('ğŸ’¾ ä¿å­˜è½‰æ›çµæœ...');
    await this.saveResults(allWords);
    
    console.log(`âœ… é·ç§»å®Œæˆï¼å…±è™•ç† ${allWords.length} å€‹è©å½™`);
  }
  
  // è½‰æ›å–®å€‹æª”æ¡ˆ
  private static async migrateFile(filename: string): Promise<VocabularyWord[]> {
    const filePath = path.join(__dirname, this.INPUT_DIR, filename);
    const content = fs.readFileSync(filePath, 'utf8');
    
    // è§£æTypeScriptæª”æ¡ˆä¸­çš„è©å½™é™£åˆ—
    const words = this.parseTypeScriptArray(content);
    
    // è½‰æ›ç‚ºçµ±ä¸€æ ¼å¼
    return words.map(word => this.convertToVocabularyWord(word, filename));
  }
  
  // è½‰æ›JLPTè©å½™
  private static async migrateJLPTWords(): Promise<VocabularyWord[]> {
    const jlptDir = path.join(__dirname, this.INPUT_DIR, 'jlpt-chunks');
    const files = fs.readdirSync(jlptDir).filter(file => file.startsWith('chunk-'));
    
    let allWords: VocabularyWord[] = [];
    
    for (const file of files) {
      const filePath = path.join(jlptDir, file);
      const content = fs.readFileSync(filePath, 'utf8');
      const words = this.parseTypeScriptArray(content);
      
      const convertedWords = words.map(word => 
        this.convertToVocabularyWord(word, `jlpt-chunks/${file}`)
      );
      
      allWords = allWords.concat(convertedWords);
    }
    
    return allWords;
  }
  
  // è½‰æ›ç‚ºçµ±ä¸€æ ¼å¼
  private static convertToVocabularyWord(word: any, source: string): VocabularyWord {
    return {
      id: word.id || this.generateId(),
      word: word.word,
      kana: word.kana,
      meaning: word.meaning,
      chineseMeaning: word.chineseMeaning || word.meaning,
      difficulty: word.difficulty,
      category: word.category || 'ä¸€èˆ¬',
      tags: this.generateTags(word),
      jlptLevel: word.jlptLevel,
      kanji: word.kanji,
      isKanji: word.isKanji || false,
      strokeCount: word.strokeCount,
      gameModes: this.determineGameModes(word),
      wordLength: word.word.length,
      frequency: word.frequency || 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      source: source
    };
  }
  
  // ç”Ÿæˆæ¨™ç±¤
  private static generateTags(word: any): string[] {
    const tags: string[] = [];
    
    // JLPTæ¨™ç±¤
    if (word.jlptLevel) {
      tags.push(`jlpt_${word.jlptLevel}`);
    }
    
    // æ¼¢å­—æ¨™ç±¤
    if (word.isKanji) {
      tags.push('kanji');
    }
    
    // å‡åæ¨™ç±¤
    if (!word.isKanji) {
      tags.push('kana');
    }
    
    // é•·åº¦æ¨™ç±¤
    if (word.word.length <= 2) {
      tags.push('short');
    } else if (word.word.length <= 4) {
      tags.push('medium');
    } else {
      tags.push('long');
    }
    
    return tags;
  }
  
  // ç¢ºå®šéŠæˆ²æ¨¡å¼
  private static determineGameModes(word: any): GameMode[] {
    const modes: GameMode[] = ['classic'];
    
    // æ ¹æ“šè©å½™ç‰¹å¾µæ±ºå®šé©ç”¨æ¨¡å¼
    if (word.isKanji) {
      modes.push('kanji');
    }
    
    if (word.word.length <= 4) {
      modes.push('tetris');
    }
    
    return modes;
  }
  
  // å»é‡è™•ç†
  private static deduplicate(words: VocabularyWord[]): VocabularyWord[] {
    const seen = new Set<string>();
    const unique: VocabularyWord[] = [];
    
    for (const word of words) {
      const key = `${word.word}-${word.kana}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(word);
      }
    }
    
    return unique;
  }
  
  // ä¿å­˜çµæœ
  private static async saveResults(words: VocabularyWord[]): Promise<void> {
    const outputPath = path.join(__dirname, this.OUTPUT_DIR, 'all-words.json');
    
    // ç¢ºä¿ç›®éŒ„å­˜åœ¨
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    
    // ä¿å­˜æ‰€æœ‰è©å½™
    fs.writeFileSync(outputPath, JSON.stringify(words, null, 2), 'utf8');
    
    // æŒ‰é›£åº¦åˆ†é¡ä¿å­˜
    const difficultyGroups = this.groupByDifficulty(words);
    for (const [difficulty, groupWords] of Object.entries(difficultyGroups)) {
      const groupPath = path.join(__dirname, this.OUTPUT_DIR, `${difficulty}.json`);
      fs.writeFileSync(groupPath, JSON.stringify(groupWords, null, 2), 'utf8');
    }
    
    // æŒ‰JLPTç­‰ç´šåˆ†é¡ä¿å­˜
    const jlptGroups = this.groupByJLPT(words);
    const jlptDir = path.join(__dirname, this.OUTPUT_DIR, 'jlpt');
    fs.mkdirSync(jlptDir, { recursive: true });
    
    for (const [level, levelWords] of Object.entries(jlptGroups)) {
      const levelPath = path.join(jlptDir, `${level}.json`);
      fs.writeFileSync(levelPath, JSON.stringify(levelWords, null, 2), 'utf8');
    }
  }
}
```

### 5.2 é©—è­‰è…³æœ¬

```typescript
// scripts/validate-vocabulary.ts
export class VocabularyValidator {
  // é©—è­‰è³‡æ–™å®Œæ•´æ€§
  static async validateIntegrity(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    await service.initialize();
    
    const words = service.getAllWords();
    const errors: string[] = [];
    
    // æª¢æŸ¥å¿…å¡«æ¬„ä½
    words.forEach((word, index) => {
      if (!word.word || !word.kana || !word.meaning) {
        errors.push(`è©å½™ ${index}: ç¼ºå°‘å¿…å¡«æ¬„ä½`);
      }
      
      if (!word.difficulty || !word.category) {
        errors.push(`è©å½™ ${index}: ç¼ºå°‘åˆ†é¡è³‡è¨Š`);
      }
      
      if (!word.gameModes || word.gameModes.length === 0) {
        errors.push(`è©å½™ ${index}: ç¼ºå°‘éŠæˆ²æ¨¡å¼`);
      }
    });
    
    // æª¢æŸ¥é‡è¤‡
    const duplicates = this.findDuplicates(words);
    if (duplicates.length > 0) {
      errors.push(`ç™¼ç¾é‡è¤‡è©å½™: ${duplicates.join(', ')}`);
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      totalWords: words.length
    };
  }
  
  // é©—è­‰çµ±è¨ˆè³‡è¨Š
  static async validateStatistics(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    const stats = service.getStatistics();
    
    const errors: string[] = [];
    
    // æª¢æŸ¥ç¸½æ•¸æ˜¯å¦åˆç†
    if (stats.totalWords < 10000) {
      errors.push('è©å½™ç¸½æ•¸éå°‘ï¼Œå¯èƒ½è³‡æ–™ä¸Ÿå¤±');
    }
    
    // æª¢æŸ¥é›£åº¦åˆ†å¸ƒ
    const difficultySum = Object.values(stats.difficultyDistribution).reduce((a, b) => a + b, 0);
    if (difficultySum !== stats.totalWords) {
      errors.push('é›£åº¦åˆ†å¸ƒçµ±è¨ˆä¸æ­£ç¢º');
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      statistics: stats
    };
  }
  
  // é©—è­‰éŠæˆ²æ¨¡å¼ç›¸å®¹æ€§
  static async validateGameModeCompatibility(): Promise<ValidationResult> {
    const service = VocabularyService.getInstance();
    const gameModes: GameMode[] = ['classic', 'tetris', 'kanji', 'long_text'];
    
    const errors: string[] = [];
    
    for (const mode of gameModes) {
      const words = service.query({ gameModes: [mode] });
      
      if (words.length === 0) {
        errors.push(`éŠæˆ²æ¨¡å¼ ${mode} æ²’æœ‰å¯ç”¨è©å½™`);
      }
      
      if (words.length < 100) {
        errors.push(`éŠæˆ²æ¨¡å¼ ${mode} è©å½™æ•¸é‡éå°‘: ${words.length}`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      gameModeStats: gameModes.map(mode => ({
        mode,
        wordCount: service.query({ gameModes: [mode] }).length
      }))
    };
  }
}
```

---

## ğŸ“ˆ é æœŸæ•ˆç›Š

### 6.1 æŠ€è¡“æ•ˆç›Š

#### 6.1.1 é–‹ç™¼æ•ˆç‡æå‡
- **çµ±ä¸€API**: æ‰€æœ‰éŠæˆ²æ¨¡å¼ä½¿ç”¨ç›¸åŒçš„è©å½™API
- **å¿«é€ŸæŸ¥è©¢**: é«˜æ•ˆçš„è©å½™æŸ¥è©¢æ©Ÿåˆ¶
- **æ˜“æ–¼æ“´å±•**: æ–°å¢éŠæˆ²æ¨¡å¼æˆ–è©å½™åˆ†é¡æ›´å®¹æ˜“
- **ç¨‹å¼ç¢¼é‡ç”¨**: æ¸›å°‘é‡è¤‡ç¨‹å¼ç¢¼

#### 6.1.2 ç¶­è­·æˆæœ¬é™ä½
- **å–®ä¸€è³‡æ–™ä¾†æº**: é¿å…è³‡æ–™ä¸ä¸€è‡´
- **è‡ªå‹•åŒ–æ¸¬è©¦**: æ›´å®¹æ˜“é€²è¡Œæ¸¬è©¦
- **ç‰ˆæœ¬æ§åˆ¶**: æ¸…æ™°çš„è®Šæ›´æ­·å²
- **æ–‡ä»¶å®Œæ•´**: æ¸…æ™°çš„APIæ–‡ä»¶

#### 6.1.3 æ€§èƒ½å„ªåŒ–
- **å¿«å–æ©Ÿåˆ¶**: æé«˜æŸ¥è©¢æ•ˆç‡
- **è¨˜æ†¶é«”å„ªåŒ–**: æ¸›å°‘é‡è¤‡è¼‰å…¥
- **æŸ¥è©¢å„ªåŒ–**: é«˜æ•ˆçš„éæ¿¾å’Œæ’åº

### 6.2 æ¥­å‹™æ•ˆç›Š

#### 6.2.1 ç®¡ç†æ•ˆç‡æå‡
- **çµ±ä¸€ç®¡ç†**: æ‰€æœ‰è©å½™åœ¨ä¸€å€‹åœ°æ–¹ç®¡ç†
- **è‡ªå‹•åŒ–**: æ¸›å°‘æ‰‹å‹•æ“ä½œéŒ¯èª¤
- **å¯è¿½è¹¤**: æ¸…æ™°çš„è®Šæ›´æ­·å²

#### 6.2.2 ç”¨æˆ¶é«”é©—æå‡
- **æ›´è±å¯Œçš„è©å½™**: æ›´å¥½çš„è©å½™åˆ†é¡å’Œæ¨™ç±¤
- **æ›´æ™ºèƒ½çš„æ¨è–¦**: åŸºæ–¼ç”¨æˆ¶è¡Œç‚ºçš„è©å½™æ¨è–¦
- **æ›´æµæš¢çš„éŠæˆ²**: æ›´å¿«çš„è©å½™è¼‰å…¥é€Ÿåº¦

#### 6.2.3 æ“´å±•æ€§æå‡
- **æ–°æ¨¡å¼æ”¯æ´**: æ›´å®¹æ˜“æ–°å¢éŠæˆ²æ¨¡å¼
- **è©å½™æ“´å±•**: æ›´å®¹æ˜“æ–°å¢è©å½™åˆ†é¡
- **åŠŸèƒ½æ“´å±•**: æ›´å®¹æ˜“æ–°å¢åŠŸèƒ½

---

## ğŸ¯ çµè«–

### 7.1 é‡æ§‹å¿…è¦æ€§

åŸºæ–¼ç•¶å‰è©å½™è³‡æ–™åº«çš„å•é¡Œåˆ†æï¼Œé‡æ§‹æ˜¯å¿…è¦çš„ï¼š

1. **æŠ€è¡“å‚µå‹™**: ç•¶å‰æ¶æ§‹å­˜åœ¨å¤§é‡æŠ€è¡“å‚µå‹™
2. **ç¶­è­·å›°é›£**: åˆ†æ•£çš„æª”æ¡ˆçµæ§‹å°è‡´ç¶­è­·å›°é›£
3. **æ“´å±•é™åˆ¶**: ç¾æœ‰æ¶æ§‹é™åˆ¶äº†åŠŸèƒ½æ“´å±•
4. **æ•ˆç‡å•é¡Œ**: é‡è¤‡çš„é‚è¼¯å’Œæª”æ¡ˆå½±éŸ¿é–‹ç™¼æ•ˆç‡

### 7.2 é‡æ§‹åƒ¹å€¼

é‡æ§‹å°‡å¸¶ä¾†ä»¥ä¸‹åƒ¹å€¼ï¼š

1. **æŠ€è¡“åƒ¹å€¼**: å»ºç«‹ç¾ä»£åŒ–çš„è©å½™ç®¡ç†ç³»çµ±
2. **æ¥­å‹™åƒ¹å€¼**: æé«˜é–‹ç™¼æ•ˆç‡å’Œç”¨æˆ¶é«”é©—
3. **é•·æœŸåƒ¹å€¼**: ç‚ºæœªä¾†æ“´å±•å¥ å®šåŸºç¤

### 7.3 å¯¦æ–½å»ºè­°

1. **åˆ†éšæ®µå¯¦æ–½**: æŒ‰ç…§è¨ˆåŠƒåˆ†éšæ®µé€²è¡Œï¼Œé™ä½é¢¨éšª
2. **å……åˆ†æ¸¬è©¦**: æ¯å€‹éšæ®µéƒ½è¦é€²è¡Œå……åˆ†æ¸¬è©¦
3. **å‘å¾Œç›¸å®¹**: ç¢ºä¿ç¾æœ‰åŠŸèƒ½ä¸å—å½±éŸ¿
4. **æŒçºŒå„ªåŒ–**: æ ¹æ“šä½¿ç”¨æƒ…æ³æŒçºŒå„ªåŒ–

### 7.4 ä¸‹ä¸€æ­¥è¡Œå‹•

1. **æŠ€è¡“è©•å¯©**: å·¥ç¨‹å¸«åœ˜éšŠè©•å¯©æŠ€è¡“æ–¹æ¡ˆ
2. **è³‡æºè¦åŠƒ**: ç¢ºå®šå¯¦æ–½æ™‚é–“å’Œäººå“¡å®‰æ’
3. **é–‹å§‹å¯¦æ–½**: æŒ‰ç…§è¨ˆåŠƒé–‹å§‹é‡æ§‹å·¥ä½œ
4. **å®šæœŸæª¢æŸ¥**: å®šæœŸæª¢æŸ¥é€²åº¦å’Œè³ªé‡

---

**æ–‡ä»¶çµæŸ**

é€™ä»½æŠ€è¡“æ–‡ä»¶æä¾›äº†å®Œæ•´çš„é‡æ§‹æ–¹æ¡ˆï¼ŒåŒ…æ‹¬å•é¡Œåˆ†æã€è¨­è¨ˆé‚è¼¯ã€å¯¦æ–½è¨ˆåŠƒå’ŒæŠ€è¡“ç´°ç¯€ã€‚å·¥ç¨‹å¸«å¯ä»¥æ ¹æ“šé€™ä»½æ–‡ä»¶è©•ä¼°æ–¹æ¡ˆçš„å¯è¡Œæ€§ï¼Œä¸¦é–‹å§‹å¯¦æ–½é‡æ§‹å·¥ä½œã€‚ 